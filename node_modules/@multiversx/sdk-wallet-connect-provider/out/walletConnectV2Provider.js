"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnectV2Provider = exports.WalletConnectV2ProviderErrorMessagesEnum = void 0;
const sign_client_1 = __importDefault(require("@walletconnect/sign-client"));
const utils_1 = require("@walletconnect/utils");
const constants_1 = require("./constants");
const operation_1 = require("./operation");
const logger_1 = require("./logger");
const primitives_1 = require("./primitives");
const errors_1 = require("./errors");
Object.defineProperty(exports, "WalletConnectV2ProviderErrorMessagesEnum", { enumerable: true, get: function () { return errors_1.WalletConnectV2ProviderErrorMessagesEnum; } });
const userAddress_1 = require("./userAddress");
class WalletConnectV2Provider {
    constructor(onClientConnect, chainId, walletConnectV2Relay, walletConnectV2ProjectId, options) {
        this.chainId = "";
        this.address = "";
        this.signature = "";
        this.namespace = constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE;
        this.isInitializing = false;
        this.events = [];
        this.methods = [];
        this.processingTopic = "";
        this.options = {};
        this.onClientConnect = onClientConnect;
        this.chainId = chainId;
        this.walletConnectV2Relay = walletConnectV2Relay;
        this.walletConnectV2ProjectId = walletConnectV2ProjectId;
        this.options = options;
    }
    reset() {
        this.address = "";
        this.signature = "";
        this.namespace = constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE;
        this.session = undefined;
    }
    /**
     * Initiates WalletConnect client.
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isInitialized()) {
                return this.isInitialized();
            }
            else {
                try {
                    if (!this.isInitializing) {
                        this.isInitializing = true;
                        this.reset();
                        const client = yield sign_client_1.default.init(Object.assign({ relayUrl: this.walletConnectV2Relay, projectId: this.walletConnectV2ProjectId }, this.options));
                        this.walletConnector = client;
                        this.isInitializing = false;
                        yield this.subscribeToEvents(client);
                        yield this.checkPersistedState(client);
                    }
                }
                catch (error) {
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToInit);
                }
                finally {
                    this.isInitializing = false;
                    return this.isInitialized();
                }
            }
        });
    }
    /**
     * Returns true if init() was previously called successfully
     */
    isInitialized() {
        return !!this.walletConnector && !this.isInitializing;
    }
    /**
     * Returns true if provider is initialized and a valid session is set
     */
    isConnected() {
        return new Promise((resolve, _) => resolve(Boolean(this.isInitialized() && typeof this.session !== "undefined")));
    }
    connect(options) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            const connectParams = this.getConnectionParams(options);
            try {
                const response = yield this.walletConnector.connect(Object.assign({ pairingTopic: options === null || options === void 0 ? void 0 : options.topic }, connectParams));
                this.events = (_b = (_a = connectParams === null || connectParams === void 0 ? void 0 : connectParams.requiredNamespaces) === null || _a === void 0 ? void 0 : _a[constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE]) === null || _b === void 0 ? void 0 : _b.events;
                this.methods = (_d = (_c = connectParams === null || connectParams === void 0 ? void 0 : connectParams.requiredNamespaces) === null || _c === void 0 ? void 0 : _c[constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE]) === null || _d === void 0 ? void 0 : _d.methods;
                return response;
            }
            catch (error) {
                this.reset();
                logger_1.Logger.error((options === null || options === void 0 ? void 0 : options.topic) ? errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnectExisting
                    : errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnect);
                throw new Error((options === null || options === void 0 ? void 0 : options.topic) ? errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnectExisting
                    : errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToConnect);
            }
        });
    }
    login(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.isInitializing = true;
            if (typeof this.walletConnector === "undefined") {
                yield this.connect();
            }
            if (typeof this.walletConnector === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session !== "undefined") {
                yield this.logout({ topic: (_a = this.session) === null || _a === void 0 ? void 0 : _a.topic });
            }
            try {
                if (options && options.approval) {
                    const session = yield options.approval();
                    if (options.token) {
                        const address = this.getAddressFromSession(session);
                        const { signature } = yield this.walletConnector.request({
                            chainId: `${this.namespace}:${this.chainId}`,
                            topic: session.topic,
                            request: {
                                method: operation_1.Operation.SIGN_LOGIN_TOKEN,
                                params: {
                                    token: options.token,
                                    address,
                                },
                            },
                        });
                        if (!signature) {
                            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToSignLoginToken);
                            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToSignLoginToken);
                        }
                        return yield this.onSessionConnected({
                            session,
                            signature,
                        });
                    }
                    return yield this.onSessionConnected({
                        session,
                        signature: "",
                    });
                }
            }
            catch (error) {
                this.reset();
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToLogin);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToLogin);
            }
            finally {
                this.isInitializing = false;
            }
            return "";
        });
    }
    /**
     * Mocks a logout request by returning true
     */
    logout(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            try {
                if (this.processingTopic ===
                    ((options === null || options === void 0 ? void 0 : options.topic) || this.getCurrentTopic(this.walletConnector))) {
                    return true;
                }
                if (options === null || options === void 0 ? void 0 : options.topic) {
                    this.processingTopic = options.topic;
                    yield this.walletConnector.disconnect({
                        topic: options.topic,
                        reason: utils_1.getSdkError("USER_DISCONNECTED"),
                    });
                }
                else {
                    const currentSessionTopic = this.getCurrentTopic(this.walletConnector);
                    this.processingTopic = currentSessionTopic;
                    yield this.walletConnector.disconnect({
                        topic: currentSessionTopic,
                        reason: utils_1.getSdkError("USER_DISCONNECTED"),
                    });
                    this.reset();
                    yield this.cleanupPendingPairings({ deletePairings: true });
                }
            }
            catch (_a) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.alreadyLoggedOut);
            }
            finally {
                this.processingTopic = "";
            }
            return true;
        });
    }
    /**
     * Fetches the WalletConnect address
     */
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            return this.address;
        });
    }
    /**
     * Fetches the WalletConnect signature
     */
    getSignature() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            return this.signature;
        });
    }
    /**
     * Fetches the WalletConnect pairings
     */
    getPairings() {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            return ((_e = (_d = (_c = (_b = (_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.core) === null || _b === void 0 ? void 0 : _b.pairing) === null || _c === void 0 ? void 0 : _c.pairings) === null || _d === void 0 ? void 0 : _d.getAll({ active: true })) !== null && _e !== void 0 ? _e : []);
        });
    }
    /**
     * Signs a message and returns it signed
     * @param message
     */
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
                this.onClientConnect.onClientLogout();
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            const address = yield this.getAddress();
            const { signature } = yield this.walletConnector.request({
                chainId: `${this.namespace}:${this.chainId}`,
                topic: this.getCurrentTopic(this.walletConnector),
                request: {
                    method: operation_1.Operation.SIGN_MESSAGE,
                    params: {
                        address,
                        message: message.message.toString(),
                    },
                },
            });
            if (!signature) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageResponse);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageResponse);
            }
            try {
                message.applySignature(new primitives_1.Signature(signature), userAddress_1.UserAddress.fromBech32(address));
            }
            catch (error) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageSignature);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidMessageSignature);
            }
            return message;
        });
    }
    /**
     * Signs a transaction and returns it signed
     * @param transaction
     */
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
                this.onClientConnect.onClientLogout();
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            const address = yield this.getAddress();
            const sender = new primitives_1.Address(address);
            const wcTransaction = transaction.toPlainObject(sender);
            if (this.chainId !== transaction.getChainID().valueOf()) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
            }
            try {
                const { signature } = yield this.walletConnector.request({
                    chainId: `${this.namespace}:${this.chainId}`,
                    topic: this.getCurrentTopic(this.walletConnector),
                    request: {
                        method: operation_1.Operation.SIGN_TRANSACTION,
                        params: {
                            transaction: wcTransaction,
                        },
                    },
                });
                if (!signature) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
                }
                transaction.applySignature(primitives_1.Signature.fromHex(signature), userAddress_1.UserAddress.fromBech32(address));
                return transaction;
            }
            catch (error) {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.transactionError);
            }
        });
    }
    /**
     * Signs an array of transactions and returns it signed
     * @param transactions
     */
    signTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
                this.onClientConnect.onClientLogout();
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            const address = yield this.getAddress();
            const sender = new primitives_1.Address(address);
            const wcTransactions = transactions.map((transaction) => {
                if (this.chainId !== transaction.getChainID().valueOf()) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.requestDifferentChain);
                }
                return transaction.toPlainObject(sender);
            });
            try {
                const { signatures } = yield this.walletConnector.request({
                    chainId: `${this.namespace}:${this.chainId}`,
                    topic: this.getCurrentTopic(this.walletConnector),
                    request: {
                        method: operation_1.Operation.SIGN_TRANSACTIONS,
                        params: {
                            transactions: wcTransactions,
                        },
                    },
                });
                if (!signatures || !Array.isArray(signatures)) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
                }
                if (transactions.length !== signatures.length) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidTransactionResponse);
                }
                for (const [index, transaction] of transactions.entries()) {
                    transaction.applySignature(primitives_1.Signature.fromHex(signatures[index].signature), userAddress_1.UserAddress.fromBech32(address));
                }
                return transactions;
            }
            catch (error) {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.transactionError);
            }
        });
    }
    /**
     * Sends a custom request
     * @param request
     */
    sendCustomRequest(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
                this.onClientConnect.onClientLogout();
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            if ((_a = options === null || options === void 0 ? void 0 : options.request) === null || _a === void 0 ? void 0 : _a.method) {
                const request = Object.assign({}, options.request);
                let { method } = request;
                const { response } = yield this.walletConnector.request({
                    chainId: `${this.namespace}:${this.chainId}`,
                    topic: this.getCurrentTopic(this.walletConnector),
                    request: Object.assign(Object.assign({}, request), { method }),
                });
                if (!response) {
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidCustomRequestResponse);
                    throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidCustomRequestResponse);
                }
                return response;
            }
        });
    }
    /**
     * Ping helper
     */
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            }
            try {
                const topic = this.getCurrentTopic(this.walletConnector);
                yield this.walletConnector.ping({
                    topic,
                });
                return true;
            }
            catch (error) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.pingFailed);
                return false;
            }
        });
    }
    loginAccount(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options) {
                return "";
            }
            if (this.addressIsValid(options.address)) {
                this.address = options.address;
                if (options.signature) {
                    this.signature = options.signature;
                }
                this.onClientConnect.onClientLogin();
                return this.address;
            }
            logger_1.Logger.error(`${errors_1.WalletConnectV2ProviderErrorMessagesEnum.invalidAddress} ${options.address}`);
            if (this.walletConnector) {
                yield this.logout();
            }
            return "";
        });
    }
    onSessionConnected(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options) {
                return "";
            }
            this.session = options.session;
            const address = this.getAddressFromSession(options.session);
            if (address) {
                yield this.loginAccount({ address, signature: options.signature });
                return address;
            }
            return "";
        });
    }
    handleTopicUpdateEvent({ topic, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            try {
                const existingPairings = yield this.getPairings();
                if (this.address && !this.isInitializing && existingPairings) {
                    if ((existingPairings === null || existingPairings === void 0 ? void 0 : existingPairings.length) === 0) {
                        this.onClientConnect.onClientLogout();
                    }
                    else {
                        const lastActivePairing = existingPairings[existingPairings.length - 1];
                        if ((lastActivePairing === null || lastActivePairing === void 0 ? void 0 : lastActivePairing.topic) === topic) {
                            this.onClientConnect.onClientLogout();
                        }
                    }
                }
            }
            catch (error) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleTopic);
            }
            finally {
                this.pairings = yield this.getPairings();
            }
        });
    }
    handleSessionEvents({ topic, params, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            if (this.session && ((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) !== topic) {
                return;
            }
            const { event } = params;
            if ((event === null || event === void 0 ? void 0 : event.name) && this.getCurrentTopic(this.walletConnector) === topic) {
                const eventData = event.data;
                this.onClientConnect.onClientEvent(eventData);
            }
        });
    }
    subscribeToEvents(client) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof client === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            try {
                // Session Events
                client.on("session_update", ({ topic, params }) => {
                    var _a;
                    if (!this.session || ((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) !== topic) {
                        return;
                    }
                    const { namespaces } = params;
                    const _session = client.session.get(topic);
                    const updatedSession = Object.assign(Object.assign({}, _session), { namespaces });
                    this.onSessionConnected({ session: updatedSession });
                });
                client.on("session_event", this.handleSessionEvents.bind(this));
                client.on("session_delete", ({ topic }) => __awaiter(this, void 0, void 0, function* () {
                    var _e;
                    if (!this.session || ((_e = this.session) === null || _e === void 0 ? void 0 : _e.topic) !== topic) {
                        return;
                    }
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionDeleted);
                    this.onClientConnect.onClientLogout();
                    this.reset();
                    yield this.cleanupPendingPairings({ deletePairings: true });
                }));
                client.on("session_expire", ({ topic }) => __awaiter(this, void 0, void 0, function* () {
                    var _f;
                    if (!this.session || ((_f = this.session) === null || _f === void 0 ? void 0 : _f.topic) !== topic) {
                        return;
                    }
                    logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionExpired);
                    this.onClientConnect.onClientLogout();
                    this.reset();
                    yield this.cleanupPendingPairings({ deletePairings: true });
                }));
                // Pairing Events
                (_b = (_a = client.core) === null || _a === void 0 ? void 0 : _a.pairing) === null || _b === void 0 ? void 0 : _b.events.on("pairing_delete", this.handleTopicUpdateEvent.bind(this));
                (_d = (_c = client.core) === null || _c === void 0 ? void 0 : _c.pairing) === null || _d === void 0 ? void 0 : _d.events.on("pairing_expire", this.handleTopicUpdateEvent.bind(this));
            }
            catch (error) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleEvent);
            }
        });
    }
    checkPersistedState(client) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof client === "undefined") {
                throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
            }
            this.pairings = yield this.getPairings();
            if (typeof this.session !== "undefined") {
                return;
            }
            // Populates existing session to state (assume only the top one)
            if (client.session.length && !this.address && !this.isInitializing) {
                const session = this.getCurrentSession(client);
                if (session) {
                    yield this.onSessionConnected({ session });
                    return session;
                }
            }
            return;
        });
    }
    cleanupPendingPairings(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                return;
            }
            try {
                const inactivePairings = (_c = (_b = (_a = this.walletConnector.core) === null || _a === void 0 ? void 0 : _a.pairing) === null || _b === void 0 ? void 0 : _b.pairings) === null || _c === void 0 ? void 0 : _c.getAll();
                if (!utils_1.isValidArray(inactivePairings)) {
                    return;
                }
                for (const pairing of inactivePairings) {
                    if (options.deletePairings) {
                        (_e = (_d = this.walletConnector.core) === null || _d === void 0 ? void 0 : _d.expirer) === null || _e === void 0 ? void 0 : _e.set(pairing.topic, 0);
                    }
                    else {
                        yield ((_h = (_g = (_f = this.walletConnector.core) === null || _f === void 0 ? void 0 : _f.relayer) === null || _g === void 0 ? void 0 : _g.subscriber) === null || _h === void 0 ? void 0 : _h.unsubscribe(pairing.topic));
                    }
                }
            }
            catch (error) {
                logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.unableToHandleCleanup);
            }
        });
    }
    getCurrentSession(client) {
        if (typeof client === "undefined") {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
        }
        const acknowledgedSessions = client
            .find(this.getConnectionParams())
            .filter((s) => s.acknowledged);
        if (acknowledgedSessions.length > 0) {
            const lastKeyIndex = acknowledgedSessions.length - 1;
            const session = acknowledgedSessions[lastKeyIndex];
            return session;
        }
        else if (client.session.length > 0) {
            const lastKeyIndex = client.session.keys.length - 1;
            const session = client.session.get(client.session.keys[lastKeyIndex]);
            return session;
        }
        else {
            logger_1.Logger.error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
        }
    }
    getCurrentTopic(client) {
        if (typeof client === "undefined") {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.notInitialized);
        }
        const session = this.getCurrentSession(client);
        if (session === null || session === void 0 ? void 0 : session.topic) {
            return session.topic;
        }
        else {
            throw new Error(errors_1.WalletConnectV2ProviderErrorMessagesEnum.sessionNotConnected);
        }
    }
    getConnectionParams(options) {
        var _a, _b;
        const methods = [
            ...constants_1.WALLETCONNECT_MULTIVERSX_METHODS,
            ...((_a = options === null || options === void 0 ? void 0 : options.methods) !== null && _a !== void 0 ? _a : []),
        ];
        const chains = [`${constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE}:${this.chainId}`];
        const events = (_b = options === null || options === void 0 ? void 0 : options.events) !== null && _b !== void 0 ? _b : [];
        return {
            requiredNamespaces: {
                [constants_1.WALLETCONNECT_MULTIVERSX_NAMESPACE]: {
                    methods,
                    chains,
                    events,
                },
            },
        };
    }
    addressIsValid(destinationAddress) {
        try {
            const addr = userAddress_1.UserAddress.fromBech32(destinationAddress);
            return !!addr;
        }
        catch (_a) {
            return false;
        }
    }
    getAddressFromSession(session) {
        const selectedNamespace = session.namespaces[this.namespace];
        if (selectedNamespace && selectedNamespace.accounts) {
            // Use only the first address in case of multiple provided addresses
            const currentSession = selectedNamespace.accounts[0];
            const [namespace, reference, address] = currentSession.split(":");
            return address;
        }
        return "";
    }
}
exports.WalletConnectV2Provider = WalletConnectV2Provider;
//# sourceMappingURL=walletConnectV2Provider.js.map