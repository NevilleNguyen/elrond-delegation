{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Decryptor = void 0;\nvar crypto_1 = __importDefault(require(\"crypto\"));\nvar constants_1 = require(\"./constants\");\nvar errors_1 = require(\"../errors\");\nvar Decryptor = /*#__PURE__*/function () {\n  function Decryptor() {\n    _classCallCheck(this, Decryptor);\n  }\n  _createClass(Decryptor, null, [{\n    key: \"decrypt\",\n    value: function decrypt(data, password) {\n      var kdfparams = data.kdfparams;\n      var salt = Buffer.from(data.salt, \"hex\");\n      var iv = Buffer.from(data.iv, \"hex\");\n      var ciphertext = Buffer.from(data.ciphertext, \"hex\");\n      var derivedKey = kdfparams.generateDerivedKey(Buffer.from(password), salt);\n      var derivedKeyFirstHalf = derivedKey.slice(0, 16);\n      var derivedKeySecondHalf = derivedKey.slice(16, 32);\n      var computedMAC = crypto_1.default.createHmac(constants_1.DigestAlgorithm, derivedKeySecondHalf).update(ciphertext).digest();\n      var actualMAC = data.mac;\n      if (computedMAC.toString(\"hex\") !== actualMAC) {\n        throw new errors_1.Err(\"MAC mismatch, possibly wrong password\");\n      }\n      var decipher = crypto_1.default.createDecipheriv(data.cipher, derivedKeyFirstHalf, iv);\n      return Buffer.concat([decipher.update(ciphertext), decipher.final()]);\n    }\n  }]);\n  return Decryptor;\n}();\nexports.Decryptor = Decryptor;","map":{"version":3,"sources":["../../src/crypto/decryptor.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;AAEA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AAAgC,IAEnB,SAAS;EAAA,SAAA,UAAA;IAAA,eAAA,OAAA,SAAA;EAAA;EAAA,YAAA,CAAA,SAAA;IAAA,GAAA;IAAA,KAAA,EACpB,SAAA,QAAe,IAAmB,EAAE,QAAgB,EAAA;MAClD,IAAM,SAAS,GAAG,IAAI,CAAC,SAAS;MAChC,IAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC;MAC1C,IAAM,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC;MACtC,IAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC;MACtD,IAAM,UAAU,GAAG,SAAS,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC;MAC5E,IAAM,mBAAmB,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;MACnD,IAAM,oBAAoB,GAAG,UAAU,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;MAErD,IAAM,WAAW,GAAG,QAAA,CAAA,OAAM,CAAC,UAAU,CAAC,WAAA,CAAA,eAAe,EAAE,oBAAoB,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,MAAM,EAAE;MACxG,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG;MAE1B,IAAI,WAAW,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,SAAS,EAAE;QAC7C,MAAM,IAAI,QAAA,CAAA,GAAG,CAAC,uCAAuC,CAAC;MACvD;MAED,IAAM,QAAQ,GAAG,QAAA,CAAA,OAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,MAAM,EAAE,mBAAmB,EAAE,EAAE,CAAC;MAE9E,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC;IACvE;EAAC;EAAA,OAAA,SAAA;AAAA;AApBH,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decryptor = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst constants_1 = require(\"./constants\");\nconst errors_1 = require(\"../errors\");\nclass Decryptor {\n    static decrypt(data, password) {\n        const kdfparams = data.kdfparams;\n        const salt = Buffer.from(data.salt, \"hex\");\n        const iv = Buffer.from(data.iv, \"hex\");\n        const ciphertext = Buffer.from(data.ciphertext, \"hex\");\n        const derivedKey = kdfparams.generateDerivedKey(Buffer.from(password), salt);\n        const derivedKeyFirstHalf = derivedKey.slice(0, 16);\n        const derivedKeySecondHalf = derivedKey.slice(16, 32);\n        const computedMAC = crypto_1.default.createHmac(constants_1.DigestAlgorithm, derivedKeySecondHalf).update(ciphertext).digest();\n        const actualMAC = data.mac;\n        if (computedMAC.toString(\"hex\") !== actualMAC) {\n            throw new errors_1.Err(\"MAC mismatch, possibly wrong password\");\n        }\n        const decipher = crypto_1.default.createDecipheriv(data.cipher, derivedKeyFirstHalf, iv);\n        return Buffer.concat([decipher.update(ciphertext), decipher.final()]);\n    }\n}\nexports.Decryptor = Decryptor;\n//# sourceMappingURL=decryptor.js.map"]},"metadata":{},"sourceType":"script"}