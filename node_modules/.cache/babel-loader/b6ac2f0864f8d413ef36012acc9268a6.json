{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentErrorContext = void 0;\nvar errors_1 = require(\"../errors\");\nvar ArgumentErrorContext = /*#__PURE__*/function () {\n  function ArgumentErrorContext(endpointName, argumentIndex, parameterDefinition) {\n    _classCallCheck(this, ArgumentErrorContext);\n    this.endpointName = endpointName;\n    this.argumentIndex = argumentIndex;\n    this.parameterDefinition = parameterDefinition;\n  }\n  _createClass(ArgumentErrorContext, [{\n    key: \"throwError\",\n    value: function throwError(specificError) {\n      throw new errors_1.ErrInvalidArgument(\"Error when converting arguments for endpoint (endpoint name: \".concat(this.endpointName, \", argument index: \").concat(this.argumentIndex, \", name: \").concat(this.parameterDefinition.name, \", type: \").concat(this.parameterDefinition.type, \")\\nNested error: \").concat(specificError));\n    }\n  }, {\n    key: \"convertError\",\n    value: function convertError(native, typeName) {\n      this.throwError(\"Can't convert argument (argument: \".concat(native, \", type \").concat(typeof native, \"), wanted type: \").concat(typeName, \")\"));\n    }\n  }, {\n    key: \"unhandledType\",\n    value: function unhandledType(functionName, type) {\n      this.throwError(\"Unhandled type (function: \".concat(functionName, \", type: \").concat(type, \")\"));\n    }\n  }, {\n    key: \"guardSameLength\",\n    value: function guardSameLength(native, valueTypes) {\n      native = native || [];\n      if (native.length != valueTypes.length) {\n        this.throwError(\"Incorrect composite type length: have \".concat(native.length, \", expected \").concat(valueTypes.length, \" (argument: \").concat(native, \")\"));\n      }\n    }\n  }, {\n    key: \"guardHasField\",\n    value: function guardHasField(native, fieldName) {\n      native = native || {};\n      if (!(fieldName in native)) {\n        this.throwError(\"Struct argument does not contain a field named \\\"\".concat(fieldName, \"\\\" (argument: \").concat(JSON.stringify(native), \")\"));\n      }\n    }\n  }]);\n  return ArgumentErrorContext;\n}();\nexports.ArgumentErrorContext = ArgumentErrorContext;","map":{"version":3,"sources":["../../src/smartcontracts/argumentErrorContext.ts"],"names":[],"mappings":";;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AAA+C,IAGlC,oBAAoB;EAK7B,SAAA,qBAAY,YAAoB,EAAE,aAAqB,EAAE,mBAAgD,EAAA;IAAA,eAAA,OAAA,oBAAA;IACrG,IAAI,CAAC,YAAY,GAAG,YAAY;IAChC,IAAI,CAAC,aAAa,GAAG,aAAa;IAClC,IAAI,CAAC,mBAAmB,GAAG,mBAAmB;EAClD;EAAC,YAAA,CAAA,oBAAA;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,WAAW,aAAqB,EAAA;MAC5B,MAAM,IAAI,QAAA,CAAA,kBAAkB,iEAAA,MAAA,CAAiE,IAAI,CAAC,YAAY,wBAAA,MAAA,CAAqB,IAAI,CAAC,aAAa,cAAA,MAAA,CAAW,IAAI,CAAC,mBAAmB,CAAC,IAAI,cAAA,MAAA,CAAW,IAAI,CAAC,mBAAmB,CAAC,IAAI,uBAAA,MAAA,CAAoB,aAAa,EAAG;IAC7Q;EAAC;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,aAAa,MAAW,EAAE,QAAgB,EAAA;MACtC,IAAI,CAAC,UAAU,sCAAA,MAAA,CAAsC,MAAM,aAAA,MAAA,CAAU,OAAO,MAAM,sBAAA,MAAA,CAAmB,QAAQ,OAAI;IACrH;EAAC;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,cAAc,YAAoB,EAAE,IAAU,EAAA;MAC1C,IAAI,CAAC,UAAU,8BAAA,MAAA,CAA8B,YAAY,cAAA,MAAA,CAAW,IAAI,OAAI;IAChF;EAAC;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,gBAAmB,MAAa,EAAE,UAAe,EAAA;MAC7C,MAAM,GAAG,MAAM,IAAI,EAAE;MACrB,IAAI,MAAM,CAAC,MAAM,IAAI,UAAU,CAAC,MAAM,EAAE;QACpC,IAAI,CAAC,UAAU,0CAAA,MAAA,CAA0C,MAAM,CAAC,MAAM,iBAAA,MAAA,CAAc,UAAU,CAAC,MAAM,kBAAA,MAAA,CAAe,MAAM,OAAI;MACjI;IACL;EAAC;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,cAAc,MAAW,EAAE,SAAiB,EAAA;MACxC,MAAM,GAAG,MAAM,IAAI,CAAA,CAAE;MACrB,IAAI,EAAE,SAAS,IAAI,MAAM,CAAC,EAAE;QACxB,IAAI,CAAC,UAAU,qDAAA,MAAA,CAAoD,SAAS,oBAAA,MAAA,CAAgB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,OAAI;MACzH;IACL;EAAC;EAAA,OAAA,oBAAA;AAAA;AAnCL,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArgumentErrorContext = void 0;\nconst errors_1 = require(\"../errors\");\nclass ArgumentErrorContext {\n    constructor(endpointName, argumentIndex, parameterDefinition) {\n        this.endpointName = endpointName;\n        this.argumentIndex = argumentIndex;\n        this.parameterDefinition = parameterDefinition;\n    }\n    throwError(specificError) {\n        throw new errors_1.ErrInvalidArgument(`Error when converting arguments for endpoint (endpoint name: ${this.endpointName}, argument index: ${this.argumentIndex}, name: ${this.parameterDefinition.name}, type: ${this.parameterDefinition.type})\\nNested error: ${specificError}`);\n    }\n    convertError(native, typeName) {\n        this.throwError(`Can't convert argument (argument: ${native}, type ${typeof native}), wanted type: ${typeName})`);\n    }\n    unhandledType(functionName, type) {\n        this.throwError(`Unhandled type (function: ${functionName}, type: ${type})`);\n    }\n    guardSameLength(native, valueTypes) {\n        native = native || [];\n        if (native.length != valueTypes.length) {\n            this.throwError(`Incorrect composite type length: have ${native.length}, expected ${valueTypes.length} (argument: ${native})`);\n        }\n    }\n    guardHasField(native, fieldName) {\n        native = native || {};\n        if (!(fieldName in native)) {\n            this.throwError(`Struct argument does not contain a field named \"${fieldName}\" (argument: ${JSON.stringify(native)})`);\n        }\n    }\n}\nexports.ArgumentErrorContext = ArgumentErrorContext;\n//# sourceMappingURL=argumentErrorContext.js.map"]},"metadata":{},"sourceType":"script"}