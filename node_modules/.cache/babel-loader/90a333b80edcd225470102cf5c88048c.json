{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar CLA = 0xed;\nvar SIGN_RAW_TX_INS = 0x04;\nvar SIGN_HASH_TX_INS = 0x07;\nvar SIGN_MESSAGE_INS = 0x06;\nvar PROVIDE_ESDT_INFO_INS = 0x08;\nvar GET_ADDRESS_AUTH_TOKEN_INS = 0x09;\nvar ACTIVE_SIGNERS = [SIGN_RAW_TX_INS, SIGN_HASH_TX_INS, SIGN_MESSAGE_INS, GET_ADDRESS_AUTH_TOKEN_INS];\nvar LedgerApp = /*#__PURE__*/function () {\n  function LedgerApp(transport) {\n    var scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"eGLD\";\n    _classCallCheck(this, LedgerApp);\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"setAddress\", \"signTransaction\", \"signMessage\", \"getAppConfiguration\", \"getAddressAndSignAuthToken\", \"provideESDTInfo\"], scrambleKey);\n  }\n  _createClass(LedgerApp, [{\n    key: \"getAddress\",\n    value: function getAddress(account, index, display) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var ins, p1, p2, data, response, addressLength, address;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              ins = 0x03;\n              p1 = display ? 0x01 : 0x00;\n              p2 = 0x00;\n              data = Buffer.alloc(8);\n              data.writeInt32BE(account, 0);\n              data.writeUInt32BE(index, 4);\n              _context.next = 8;\n              return this.transport.send(CLA, ins, p1, p2, data);\n            case 8:\n              response = _context.sent;\n              addressLength = response[0];\n              address = Buffer.from(response.subarray(1, 1 + addressLength)).toString(\"ascii\");\n              return _context.abrupt(\"return\", {\n                address: address\n              });\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"setAddress\",\n    value: function setAddress(account, index, display) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var ins, p1, p2, data;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              ins = 0x05;\n              p1 = display ? 0x01 : 0x00;\n              p2 = 0x00;\n              data = Buffer.alloc(8);\n              data.writeInt32BE(account, 0);\n              data.writeUInt32BE(index, 4);\n              _context2.next = 8;\n              return this.transport.send(CLA, ins, p1, p2, data);\n            case 8:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(rawTx, usingHash) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", usingHash ? this.sign(rawTx, SIGN_HASH_TX_INS) : this.sign(rawTx, SIGN_RAW_TX_INS));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", this.sign(message, SIGN_MESSAGE_INS));\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"getAddressAndSignAuthToken\",\n    value: function getAddressAndSignAuthToken(account, index, token) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var data, buffersArray, result, splitRes;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              data = Buffer.alloc(12);\n              data.writeInt32BE(account, 0);\n              data.writeUInt32BE(index, 4);\n              data.writeUInt32BE(token.length, 8);\n              buffersArray = [data, token];\n              _context5.next = 7;\n              return this.sign(Buffer.concat(buffersArray), GET_ADDRESS_AUTH_TOKEN_INS);\n            case 7:\n              result = _context5.sent;\n              splitRes = result.split(\"|\");\n              return _context5.abrupt(\"return\", {\n                address: splitRes[0],\n                signature: splitRes[1]\n              });\n            case 10:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"getAppConfiguration\",\n    value: function getAppConfiguration() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var response, accountIndex, addressIndex;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.transport.send(0xed, 0x02, 0x00, 0x00);\n            case 2:\n              response = _context6.sent;\n              accountIndex = 0;\n              addressIndex = 0;\n              if (response.length === 14) {\n                // check if the response if from a version newer than 1.0.16\n                accountIndex = this.getIntValueFromBytes(response.slice(6, 10));\n                addressIndex = this.getIntValueFromBytes(response.slice(10, 14));\n              }\n              return _context6.abrupt(\"return\", {\n                contractData: response[0],\n                accountIndex: accountIndex,\n                addressIndex: addressIndex,\n                version: \"\".concat(response[3], \".\").concat(response[4], \".\").concat(response[5])\n              });\n            case 7:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"getIntValueFromBytes\",\n    value: function getIntValueFromBytes(buffer) {\n      return buffer[buffer.length - 1] | buffer[buffer.length - 2] << 8 | buffer[buffer.length - 3] << 16 | buffer[buffer.length - 4] << 24;\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(message, type) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var apdus, offset, isFirst, maxChunkSize, hasMore, chunkSize, apdu, response, _i, _apdus, _apdu;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (ACTIVE_SIGNERS.includes(type)) {\n                _context7.next = 2;\n                break;\n              }\n              throw new Error(\"invalid sign instruction called: \".concat(type));\n            case 2:\n              apdus = [];\n              offset = 0;\n              while (offset !== message.length) {\n                isFirst = offset === 0;\n                maxChunkSize = 150;\n                hasMore = offset + maxChunkSize < message.length;\n                chunkSize = hasMore ? maxChunkSize : message.length - offset;\n                apdu = {\n                  cla: CLA,\n                  ins: type,\n                  p1: isFirst ? 0x00 : 0x80,\n                  p2: 0x00,\n                  data: Buffer.alloc(chunkSize)\n                };\n                message.copy(apdu.data, 0, offset, offset + chunkSize);\n                apdus.push(apdu);\n                offset += chunkSize;\n              }\n              response = Buffer.alloc(0);\n              _i = 0, _apdus = apdus;\n            case 7:\n              if (!(_i < _apdus.length)) {\n                _context7.next = 15;\n                break;\n              }\n              _apdu = _apdus[_i];\n              _context7.next = 11;\n              return this.transport.send(_apdu.cla, _apdu.ins, _apdu.p1, _apdu.p2, _apdu.data);\n            case 11:\n              response = _context7.sent;\n            case 12:\n              _i++;\n              _context7.next = 7;\n              break;\n            case 15:\n              if (!(GET_ADDRESS_AUTH_TOKEN_INS === type)) {\n                _context7.next = 17;\n                break;\n              }\n              return _context7.abrupt(\"return\", this.handleAuthTokenResponse(response));\n            case 17:\n              if (!(response.length !== 67 || response[0] !== 64)) {\n                _context7.next = 19;\n                break;\n              }\n              throw new Error(\"invalid signature received from ledger device\");\n            case 19:\n              return _context7.abrupt(\"return\", response.slice(1, response.length - 2).toString(\"hex\"));\n            case 20:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"handleAuthTokenResponse\",\n    value: function handleAuthTokenResponse(response) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var address, signature;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!(response.length !== 129 && response[0] !== 126)) {\n                _context8.next = 2;\n                break;\n              }\n              throw new Error(\"invalid address and token signature received from ledger device\");\n            case 2:\n              address = response.slice(1, 63).toString(\"ascii\");\n              signature = response.slice(63, response.length - 2).toString(\"hex\");\n              return _context8.abrupt(\"return\", address + \"|\" + signature);\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8);\n      }));\n    }\n  }, {\n    key: \"serializeESDTInfo\",\n    value: function serializeESDTInfo(ticker, id, decimals, chainId, signature) {\n      var tickerLengthBuffer = Buffer.from([ticker.length]);\n      var tickerBuffer = Buffer.from(ticker);\n      var idLengthBuffer = Buffer.from([id.length]);\n      var idBuffer = Buffer.from(id);\n      var decimalsBuffer = Buffer.from([decimals]);\n      var chainIdLengthBuffer = Buffer.from([chainId.length]);\n      var chainIdBuffer = Buffer.from(chainId);\n      var signatureBuffer = Buffer.from(signature, \"hex\");\n      var infoBuffer = [tickerLengthBuffer, tickerBuffer, idLengthBuffer, idBuffer, decimalsBuffer, chainIdLengthBuffer, chainIdBuffer, signatureBuffer];\n      return Buffer.concat(infoBuffer);\n    }\n  }, {\n    key: \"provideESDTInfo\",\n    value: function provideESDTInfo(ticker, id, decimals, chainId, signature) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              data = this.serializeESDTInfo(ticker, id, decimals, chainId, signature);\n              _context9.next = 3;\n              return this.transport.send(CLA, PROVIDE_ESDT_INFO_INS, 0x00, 0x00, data);\n            case 3:\n              return _context9.abrupt(\"return\", _context9.sent);\n            case 4:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n    }\n  }]);\n  return LedgerApp;\n}();\nexports.default = LedgerApp;","map":{"version":3,"sources":["../src/ledgerApp.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CLA = 0xed;\nconst SIGN_RAW_TX_INS = 0x04;\nconst SIGN_HASH_TX_INS = 0x07;\nconst SIGN_MESSAGE_INS = 0x06;\nconst PROVIDE_ESDT_INFO_INS = 0x08;\nconst GET_ADDRESS_AUTH_TOKEN_INS = 0x09;\nconst ACTIVE_SIGNERS = [\n    SIGN_RAW_TX_INS,\n    SIGN_HASH_TX_INS,\n    SIGN_MESSAGE_INS,\n    GET_ADDRESS_AUTH_TOKEN_INS,\n];\nclass LedgerApp {\n    constructor(transport, scrambleKey = \"eGLD\") {\n        this.transport = transport;\n        transport.decorateAppAPIMethods(this, [\n            \"getAddress\",\n            \"setAddress\",\n            \"signTransaction\",\n            \"signMessage\",\n            \"getAppConfiguration\",\n            \"getAddressAndSignAuthToken\",\n            \"provideESDTInfo\",\n        ], scrambleKey);\n    }\n    getAddress(account, index, display) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ins = 0x03;\n            const p1 = display ? 0x01 : 0x00;\n            const p2 = 0x00;\n            const data = Buffer.alloc(8);\n            data.writeInt32BE(account, 0);\n            data.writeUInt32BE(index, 4);\n            const response = yield this.transport.send(CLA, ins, p1, p2, data);\n            const addressLength = response[0];\n            const address = Buffer.from(response.subarray(1, 1 + addressLength)).toString(\"ascii\");\n            return { address };\n        });\n    }\n    setAddress(account, index, display) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ins = 0x05;\n            const p1 = display ? 0x01 : 0x00;\n            const p2 = 0x00;\n            const data = Buffer.alloc(8);\n            data.writeInt32BE(account, 0);\n            data.writeUInt32BE(index, 4);\n            return yield this.transport.send(CLA, ins, p1, p2, data);\n        });\n    }\n    signTransaction(rawTx, usingHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return usingHash\n                ? this.sign(rawTx, SIGN_HASH_TX_INS)\n                : this.sign(rawTx, SIGN_RAW_TX_INS);\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.sign(message, SIGN_MESSAGE_INS);\n        });\n    }\n    getAddressAndSignAuthToken(account, index, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = Buffer.alloc(12);\n            data.writeInt32BE(account, 0);\n            data.writeUInt32BE(index, 4);\n            data.writeUInt32BE(token.length, 8);\n            let buffersArray = [data, token];\n            let result = yield this.sign(Buffer.concat(buffersArray), GET_ADDRESS_AUTH_TOKEN_INS);\n            let splitRes = result.split(\"|\");\n            return {\n                address: splitRes[0],\n                signature: splitRes[1],\n            };\n        });\n    }\n    getAppConfiguration() {\n        return __awaiter(this, void 0, void 0, function* () {\n            /*\n            byte 0 -> is contract data enabled?\n            bytes 1,2 -> unused (kept for compatibility reasons)\n            bytes 3,4,5 -> app version\n            bytes 6,7,8,9 -> account index (big endian)     -> only for versions >= 1.0.16\n            bytes 10,11,12,13 -> address index (big endian) -> only for versions >= 1.0.16\n            */\n            const response = yield this.transport.send(0xed, 0x02, 0x00, 0x00);\n            let accountIndex = 0;\n            let addressIndex = 0;\n            if (response.length === 14) { // check if the response if from a version newer than 1.0.16\n                accountIndex = this.getIntValueFromBytes(response.slice(6, 10));\n                addressIndex = this.getIntValueFromBytes(response.slice(10, 14));\n            }\n            return {\n                contractData: response[0],\n                accountIndex: accountIndex,\n                addressIndex: addressIndex,\n                version: `${response[3]}.${response[4]}.${response[5]}`,\n            };\n        });\n    }\n    getIntValueFromBytes(buffer) {\n        return ((buffer[buffer.length - 1]) |\n            (buffer[buffer.length - 2] << 8) |\n            (buffer[buffer.length - 3] << 16) |\n            (buffer[buffer.length - 4] << 24));\n    }\n    sign(message, type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!ACTIVE_SIGNERS.includes(type)) {\n                throw new Error(`invalid sign instruction called: ${type}`);\n            }\n            const apdus = [];\n            let offset = 0;\n            while (offset !== message.length) {\n                const isFirst = offset === 0;\n                const maxChunkSize = 150;\n                const hasMore = offset + maxChunkSize < message.length;\n                const chunkSize = hasMore ? maxChunkSize : message.length - offset;\n                const apdu = {\n                    cla: CLA,\n                    ins: type,\n                    p1: isFirst ? 0x00 : 0x80,\n                    p2: 0x00,\n                    data: Buffer.alloc(chunkSize),\n                };\n                message.copy(apdu.data, 0, offset, offset + chunkSize);\n                apdus.push(apdu);\n                offset += chunkSize;\n            }\n            let response = Buffer.alloc(0);\n            for (let apdu of apdus) {\n                response = yield this.transport.send(apdu.cla, apdu.ins, apdu.p1, apdu.p2, apdu.data);\n            }\n            if (GET_ADDRESS_AUTH_TOKEN_INS === type) {\n                return this.handleAuthTokenResponse(response);\n            }\n            if (response.length !== 67 || response[0] !== 64) {\n                throw new Error(\"invalid signature received from ledger device\");\n            }\n            return response.slice(1, response.length - 2).toString(\"hex\");\n        });\n    }\n    handleAuthTokenResponse(response) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (response.length !== 129 && response[0] !== 126) {\n                throw new Error(\"invalid address and token signature received from ledger device\");\n            }\n            const address = response.slice(1, 63).toString(\"ascii\");\n            const signature = response.slice(63, response.length - 2).toString(\"hex\");\n            return address + \"|\" + signature;\n        });\n    }\n    serializeESDTInfo(ticker, id, decimals, chainId, signature) {\n        const tickerLengthBuffer = Buffer.from([ticker.length]);\n        const tickerBuffer = Buffer.from(ticker);\n        const idLengthBuffer = Buffer.from([id.length]);\n        const idBuffer = Buffer.from(id);\n        const decimalsBuffer = Buffer.from([decimals]);\n        const chainIdLengthBuffer = Buffer.from([chainId.length]);\n        const chainIdBuffer = Buffer.from(chainId);\n        const signatureBuffer = Buffer.from(signature, \"hex\");\n        let infoBuffer = [\n            tickerLengthBuffer,\n            tickerBuffer,\n            idLengthBuffer,\n            idBuffer,\n            decimalsBuffer,\n            chainIdLengthBuffer,\n            chainIdBuffer,\n            signatureBuffer,\n        ];\n        return Buffer.concat(infoBuffer);\n    }\n    provideESDTInfo(ticker, id, decimals, chainId, signature) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = this.serializeESDTInfo(ticker, id, decimals, chainId, signature);\n            return yield this.transport.send(CLA, PROVIDE_ESDT_INFO_INS, 0x00, 0x00, data);\n        });\n    }\n}\nexports.default = LedgerApp;\n//# sourceMappingURL=ledgerApp.js.map"]},"metadata":{},"sourceType":"script"}