{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar createHmac = require(\"create-hmac\");\nvar nacl = require(\"tweetnacl\");\nvar utils_1 = require(\"./utils\");\nvar ED25519_CURVE = 'ed25519 seed';\nvar HARDENED_OFFSET = 0x80000000;\nexports.getMasterKeyFromSeed = function (seed) {\n  var hmac = createHmac('sha512', ED25519_CURVE);\n  var I = hmac.update(Buffer.from(seed, 'hex')).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nvar CKDPriv = function CKDPriv(_ref, index) {\n  var key = _ref.key,\n    chainCode = _ref.chainCode;\n  var indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n  var data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);\n  var I = createHmac('sha512', chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nexports.getPublicKey = function (privateKey) {\n  var withZeroByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var keyPair = nacl.sign.keyPair.fromSeed(privateKey);\n  var signPk = keyPair.secretKey.subarray(32);\n  var zero = Buffer.alloc(1, 0);\n  return withZeroByte ? Buffer.concat([zero, Buffer.from(signPk)]) : Buffer.from(signPk);\n};\nexports.isValidPath = function (path) {\n  if (!utils_1.pathRegex.test(path)) {\n    return false;\n  }\n  return !path.split('/').slice(1).map(utils_1.replaceDerive).some(isNaN);\n};\nexports.derivePath = function (path, seed) {\n  if (!exports.isValidPath(path)) {\n    throw new Error('Invalid derivation path');\n  }\n  var _exports$getMasterKey = exports.getMasterKeyFromSeed(seed),\n    key = _exports$getMasterKey.key,\n    chainCode = _exports$getMasterKey.chainCode;\n  var segments = path.split('/').slice(1).map(utils_1.replaceDerive).map(function (el) {\n    return parseInt(el, 10);\n  });\n  return segments.reduce(function (parentKeys, segment) {\n    return CKDPriv(parentKeys, segment + HARDENED_OFFSET);\n  }, {\n    key: key,\n    chainCode: chainCode\n  });\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","createHmac","require","nacl","utils_1","ED25519_CURVE","HARDENED_OFFSET","getMasterKeyFromSeed","seed","hmac","I","update","Buffer","from","digest","IL","slice","IR","key","chainCode","CKDPriv","_ref","index","indexBuffer","allocUnsafe","writeUInt32BE","data","concat","alloc","getPublicKey","privateKey","withZeroByte","arguments","length","undefined","keyPair","sign","fromSeed","signPk","secretKey","subarray","zero","isValidPath","path","pathRegex","test","split","map","replaceDerive","some","isNaN","derivePath","Error","_exports$getMasterKey","segments","el","parseInt","reduce","parentKeys","segment"],"sources":["/Users/neville/Documents/Github/elrond-delegation/node_modules/ed25519-hd-key/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createHmac = require(\"create-hmac\");\nconst nacl = require(\"tweetnacl\");\nconst utils_1 = require(\"./utils\");\nconst ED25519_CURVE = 'ed25519 seed';\nconst HARDENED_OFFSET = 0x80000000;\nexports.getMasterKeyFromSeed = (seed) => {\n    const hmac = createHmac('sha512', ED25519_CURVE);\n    const I = hmac.update(Buffer.from(seed, 'hex')).digest();\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n};\nconst CKDPriv = ({ key, chainCode }, index) => {\n    const indexBuffer = Buffer.allocUnsafe(4);\n    indexBuffer.writeUInt32BE(index, 0);\n    const data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);\n    const I = createHmac('sha512', chainCode)\n        .update(data)\n        .digest();\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return {\n        key: IL,\n        chainCode: IR,\n    };\n};\nexports.getPublicKey = (privateKey, withZeroByte = true) => {\n    const keyPair = nacl.sign.keyPair.fromSeed(privateKey);\n    const signPk = keyPair.secretKey.subarray(32);\n    const zero = Buffer.alloc(1, 0);\n    return withZeroByte ?\n        Buffer.concat([zero, Buffer.from(signPk)]) :\n        Buffer.from(signPk);\n};\nexports.isValidPath = (path) => {\n    if (!utils_1.pathRegex.test(path)) {\n        return false;\n    }\n    return !path\n        .split('/')\n        .slice(1)\n        .map(utils_1.replaceDerive)\n        .some(isNaN);\n};\nexports.derivePath = (path, seed) => {\n    if (!exports.isValidPath(path)) {\n        throw new Error('Invalid derivation path');\n    }\n    const { key, chainCode } = exports.getMasterKeyFromSeed(seed);\n    const segments = path\n        .split('/')\n        .slice(1)\n        .map(utils_1.replaceDerive)\n        .map(el => parseInt(el, 10));\n    return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + HARDENED_OFFSET), { key, chainCode });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}