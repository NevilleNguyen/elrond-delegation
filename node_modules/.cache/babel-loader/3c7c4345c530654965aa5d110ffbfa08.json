{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiRegistry = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar utils_1 = require(\"../../utils\");\nvar contractInterface_1 = require(\"./contractInterface\");\nvar endpoint_1 = require(\"./endpoint\");\nvar enum_1 = require(\"./enum\");\nvar struct_1 = require(\"./struct\");\nvar typeMapper_1 = require(\"./typeMapper\");\nvar AbiRegistry = /*#__PURE__*/function () {\n  function AbiRegistry() {\n    _classCallCheck(this, AbiRegistry);\n    this.interfaces = [];\n    this.customTypes = [];\n  }\n  _createClass(AbiRegistry, [{\n    key: \"extend\",\n    value: function extend(json) {\n      json.types = json.types || {};\n      // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n      var iface = contractInterface_1.ContractInterface.fromJSON(json);\n      this.interfaces.push(iface);\n      for (var customTypeName in json.types) {\n        var itemJson = json.types[customTypeName];\n        var typeDiscriminant = itemJson.type;\n        // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n        itemJson.name = customTypeName;\n        var customType = this.createCustomType(typeDiscriminant, itemJson);\n        this.customTypes.push(customType);\n      }\n      return this;\n    }\n  }, {\n    key: \"createCustomType\",\n    value: function createCustomType(typeDiscriminant, json) {\n      if (typeDiscriminant == \"struct\") {\n        return struct_1.StructType.fromJSON(json);\n      }\n      if (typeDiscriminant == \"enum\") {\n        return enum_1.EnumType.fromJSON(json);\n      }\n      throw new errors.ErrTypingSystem(\"Unknown type discriminant: \".concat(typeDiscriminant));\n    }\n  }, {\n    key: \"getInterface\",\n    value: function getInterface(name) {\n      var result = this.interfaces.find(function (e) {\n        return e.name == name;\n      });\n      utils_1.guardValueIsSetWithMessage(\"interface [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getInterfaces\",\n    value: function getInterfaces(names) {\n      var _this = this;\n      return names.map(function (name) {\n        return _this.getInterface(name);\n      });\n    }\n  }, {\n    key: \"getStruct\",\n    value: function getStruct(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e.hasExactClass(struct_1.StructType.ClassName);\n      });\n      utils_1.guardValueIsSetWithMessage(\"struct [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getStructs\",\n    value: function getStructs(names) {\n      var _this2 = this;\n      return names.map(function (name) {\n        return _this2.getStruct(name);\n      });\n    }\n  }, {\n    key: \"getEnum\",\n    value: function getEnum(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e.hasExactClass(enum_1.EnumType.ClassName);\n      });\n      utils_1.guardValueIsSetWithMessage(\"enum [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getEnums\",\n    value: function getEnums(names) {\n      var _this3 = this;\n      return names.map(function (name) {\n        return _this3.getEnum(name);\n      });\n    }\n    /**\n     * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)\n     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n     *\n     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n     *\n     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n     * The result is an equivalent, more explicit ABI registry.\n     */\n  }, {\n    key: \"remapToKnownTypes\",\n    value: function remapToKnownTypes() {\n      var _newRegistry$customTy, _newRegistry$interfac;\n      var mapper = new typeMapper_1.TypeMapper([]);\n      var newCustomTypes = [];\n      var newInterfaces = [];\n      // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n      var _iterator = _createForOfIteratorHelper(this.customTypes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var type = _step.value;\n          this.mapCustomTypeDepthFirst(type, this.customTypes, mapper, newCustomTypes);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (this.customTypes.length != newCustomTypes.length) {\n        throw new errors.ErrTypingSystem(\"Did not re-map all custom types\");\n      }\n      // Then, remap types of all endpoint parameters.\n      // The mapper learned all necessary types in the previous step.\n      var _iterator2 = _createForOfIteratorHelper(this.interfaces),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var iface = _step2.value;\n          var newEndpoints = [];\n          var _iterator3 = _createForOfIteratorHelper(iface.endpoints),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var endpoint = _step3.value;\n              newEndpoints.push(mapEndpoint(endpoint, mapper));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          var newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n          newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n        }\n        // Now return the new registry, with all types remapped to known types\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var newRegistry = new AbiRegistry();\n      (_newRegistry$customTy = newRegistry.customTypes).push.apply(_newRegistry$customTy, newCustomTypes);\n      (_newRegistry$interfac = newRegistry.interfaces).push.apply(_newRegistry$interfac, newInterfaces);\n      return newRegistry;\n    }\n  }, {\n    key: \"mapCustomTypeDepthFirst\",\n    value: function mapCustomTypeDepthFirst(typeToMap, allTypesToMap, mapper, mappedTypes) {\n      var _this4 = this;\n      var hasBeenMapped = mappedTypes.findIndex(function (type) {\n        return type.getName() == typeToMap.getName();\n      }) >= 0;\n      if (hasBeenMapped) {\n        return;\n      }\n      var _iterator4 = _createForOfIteratorHelper(typeToMap.getNamesOfDependencies()),\n        _step4;\n      try {\n        var _loop = function _loop() {\n          var typeName = _step4.value;\n          var dependencyType = allTypesToMap.find(function (type) {\n            return type.getName() == typeName;\n          });\n          if (!dependencyType) {\n            // It's a type that we don't have to map (e.g. could be a primitive type).\n            return \"continue\";\n          }\n          _this4.mapCustomTypeDepthFirst(dependencyType, allTypesToMap, mapper, mappedTypes);\n        };\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _ret = _loop();\n          if (_ret === \"continue\") continue;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var mappedType = mapper.mapType(typeToMap);\n      mappedTypes.push(mappedType);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(json) {\n      var registry = new AbiRegistry().extend(json);\n      var remappedRegistry = registry.remapToKnownTypes();\n      return remappedRegistry;\n    }\n  }]);\n  return AbiRegistry;\n}();\nexports.AbiRegistry = AbiRegistry;\nfunction mapEndpoint(endpoint, mapper) {\n  var newInput = endpoint.input.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  var newOutput = endpoint.output.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/abiRegistry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbiRegistry = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst utils_1 = require(\"../../utils\");\nconst contractInterface_1 = require(\"./contractInterface\");\nconst endpoint_1 = require(\"./endpoint\");\nconst enum_1 = require(\"./enum\");\nconst struct_1 = require(\"./struct\");\nconst typeMapper_1 = require(\"./typeMapper\");\nclass AbiRegistry {\n    constructor() {\n        this.interfaces = [];\n        this.customTypes = [];\n    }\n    static create(json) {\n        let registry = new AbiRegistry().extend(json);\n        let remappedRegistry = registry.remapToKnownTypes();\n        return remappedRegistry;\n    }\n    extend(json) {\n        json.types = json.types || {};\n        // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n        let iface = contractInterface_1.ContractInterface.fromJSON(json);\n        this.interfaces.push(iface);\n        for (const customTypeName in json.types) {\n            let itemJson = json.types[customTypeName];\n            let typeDiscriminant = itemJson.type;\n            // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n            itemJson.name = customTypeName;\n            let customType = this.createCustomType(typeDiscriminant, itemJson);\n            this.customTypes.push(customType);\n        }\n        return this;\n    }\n    createCustomType(typeDiscriminant, json) {\n        if (typeDiscriminant == \"struct\") {\n            return struct_1.StructType.fromJSON(json);\n        }\n        if (typeDiscriminant == \"enum\") {\n            return enum_1.EnumType.fromJSON(json);\n        }\n        throw new errors.ErrTypingSystem(`Unknown type discriminant: ${typeDiscriminant}`);\n    }\n    getInterface(name) {\n        let result = this.interfaces.find((e) => e.name == name);\n        utils_1.guardValueIsSetWithMessage(`interface [${name}] not found`, result);\n        return result;\n    }\n    getInterfaces(names) {\n        return names.map((name) => this.getInterface(name));\n    }\n    getStruct(name) {\n        let result = this.customTypes.find((e) => e.getName() == name && e.hasExactClass(struct_1.StructType.ClassName));\n        utils_1.guardValueIsSetWithMessage(`struct [${name}] not found`, result);\n        return result;\n    }\n    getStructs(names) {\n        return names.map((name) => this.getStruct(name));\n    }\n    getEnum(name) {\n        let result = this.customTypes.find((e) => e.getName() == name && e.hasExactClass(enum_1.EnumType.ClassName));\n        utils_1.guardValueIsSetWithMessage(`enum [${name}] not found`, result);\n        return result;\n    }\n    getEnums(names) {\n        return names.map((name) => this.getEnum(name));\n    }\n    /**\n     * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)\n     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n     *\n     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n     *\n     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n     * The result is an equivalent, more explicit ABI registry.\n     */\n    remapToKnownTypes() {\n        let mapper = new typeMapper_1.TypeMapper([]);\n        let newCustomTypes = [];\n        let newInterfaces = [];\n        // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n        for (const type of this.customTypes) {\n            this.mapCustomTypeDepthFirst(type, this.customTypes, mapper, newCustomTypes);\n        }\n        if (this.customTypes.length != newCustomTypes.length) {\n            throw new errors.ErrTypingSystem(\"Did not re-map all custom types\");\n        }\n        // Then, remap types of all endpoint parameters.\n        // The mapper learned all necessary types in the previous step.\n        for (const iface of this.interfaces) {\n            let newEndpoints = [];\n            for (const endpoint of iface.endpoints) {\n                newEndpoints.push(mapEndpoint(endpoint, mapper));\n            }\n            let newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n            newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n        }\n        // Now return the new registry, with all types remapped to known types\n        let newRegistry = new AbiRegistry();\n        newRegistry.customTypes.push(...newCustomTypes);\n        newRegistry.interfaces.push(...newInterfaces);\n        return newRegistry;\n    }\n    mapCustomTypeDepthFirst(typeToMap, allTypesToMap, mapper, mappedTypes) {\n        const hasBeenMapped = mappedTypes.findIndex(type => type.getName() == typeToMap.getName()) >= 0;\n        if (hasBeenMapped) {\n            return;\n        }\n        for (const typeName of typeToMap.getNamesOfDependencies()) {\n            const dependencyType = allTypesToMap.find(type => type.getName() == typeName);\n            if (!dependencyType) {\n                // It's a type that we don't have to map (e.g. could be a primitive type).\n                continue;\n            }\n            this.mapCustomTypeDepthFirst(dependencyType, allTypesToMap, mapper, mappedTypes);\n        }\n        const mappedType = mapper.mapType(typeToMap);\n        mappedTypes.push(mappedType);\n    }\n}\nexports.AbiRegistry = AbiRegistry;\nfunction mapEndpoint(endpoint, mapper) {\n    let newInput = endpoint.input.map((e) => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n    let newOutput = endpoint.output.map((e) => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n    return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}\n//# sourceMappingURL=abiRegistry.js.map"]},"metadata":{},"sourceType":"script"}