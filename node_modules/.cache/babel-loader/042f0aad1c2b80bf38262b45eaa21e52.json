{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PubkeyEncryptor = void 0;\nvar crypto_1 = __importDefault(require(\"crypto\"));\nvar ed2curve_1 = __importDefault(require(\"ed2curve\"));\nvar tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nvar constants_1 = require(\"./constants\");\nvar x25519EncryptedData_1 = require(\"./x25519EncryptedData\");\nvar PubkeyEncryptor = /*#__PURE__*/function () {\n  function PubkeyEncryptor() {\n    _classCallCheck(this, PubkeyEncryptor);\n  }\n  _createClass(PubkeyEncryptor, null, [{\n    key: \"encrypt\",\n    value: function encrypt(data, recipientPubKey, authSecretKey) {\n      // create a new x25519 keypair that will be used for EDH\n      var edhPair = tweetnacl_1.default.sign.keyPair();\n      var recipientDHPubKey = ed2curve_1.default.convertPublicKey(recipientPubKey.valueOf());\n      if (recipientDHPubKey === null) {\n        throw new Error(\"Could not convert ed25519 public key to x25519\");\n      }\n      var edhConvertedSecretKey = ed2curve_1.default.convertSecretKey(edhPair.secretKey);\n      // For the nonce we use a random component and a deterministic one based on the message\n      //  - this is so we won't completely rely on the random number generator\n      var nonceDeterministic = crypto_1.default.createHash('sha256').update(data).digest().slice(0, constants_1.PubKeyEncNonceLength / 2);\n      var nonceRandom = tweetnacl_1.default.randomBytes(constants_1.PubKeyEncNonceLength / 2);\n      var nonce = Buffer.concat([nonceDeterministic, nonceRandom]);\n      var encryptedMessage = tweetnacl_1.default.box(data, nonce, recipientDHPubKey, edhConvertedSecretKey);\n      // Note that the ciphertext is already authenticated for the ephemeral key - but we want it authenticated by\n      //  the ed25519 key which the user interacts with. A signature over H(ciphertext | edhPubKey)\n      //  would be enough\n      var authMessage = crypto_1.default.createHash('sha256').update(Buffer.concat([encryptedMessage, edhPair.publicKey])).digest();\n      var signature = authSecretKey.sign(authMessage);\n      return new x25519EncryptedData_1.X25519EncryptedData({\n        version: constants_1.PubKeyEncVersion,\n        nonce: Buffer.from(nonce).toString('hex'),\n        cipher: constants_1.PubKeyEncCipher,\n        ciphertext: Buffer.from(encryptedMessage).toString('hex'),\n        mac: signature.toString('hex'),\n        identities: {\n          recipient: recipientPubKey.hex(),\n          ephemeralPubKey: Buffer.from(edhPair.publicKey).toString('hex'),\n          originatorPubKey: authSecretKey.generatePublicKey().hex()\n        }\n      });\n    }\n  }]);\n  return PubkeyEncryptor;\n}();\nexports.PubkeyEncryptor = PubkeyEncryptor;","map":{"version":3,"sources":["../../src/crypto/pubkeyEncryptor.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;AACA,IAAA,UAAA,GAAA,eAAA,CAAA,OAAA,CAAA,UAAA,CAAA,CAAA;AACA,IAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;AAEA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AACA,IAAA,qBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;AAA4D,IAE/C,eAAe;EAAA,SAAA,gBAAA;IAAA,eAAA,OAAA,eAAA;EAAA;EAAA,YAAA,CAAA,eAAA;IAAA,GAAA;IAAA,KAAA,EACxB,SAAA,QAAe,IAAY,EAAE,eAA8B,EAAE,aAA4B,EAAA;MACrF;MACA,IAAM,OAAO,GAAG,WAAA,CAAA,OAAI,CAAC,IAAI,CAAC,OAAO,EAAE;MACnC,IAAM,iBAAiB,GAAG,UAAA,CAAA,OAAQ,CAAC,gBAAgB,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;MAC9E,IAAI,iBAAiB,KAAK,IAAI,EAAE;QAC5B,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC;MACpE;MACD,IAAM,qBAAqB,GAAG,UAAA,CAAA,OAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC,SAAS,CAAC;MAE1E;MACA;MACA,IAAM,kBAAkB,GAAG,QAAA,CAAA,OAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,WAAA,CAAA,oBAAoB,GAAG,CAAC,CAAC;MAC/G,IAAM,WAAW,GAAG,WAAA,CAAA,OAAI,CAAC,WAAW,CAAC,WAAA,CAAA,oBAAoB,GAAG,CAAC,CAAC;MAC9D,IAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,kBAAkB,EAAE,WAAW,CAAC,CAAC;MAC9D,IAAM,gBAAgB,GAAG,WAAA,CAAA,OAAI,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,iBAAiB,EAAE,qBAAqB,CAAC;MAExF;MACA;MACA;MACA,IAAM,WAAW,GAAG,QAAA,CAAA,OAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAClD,MAAM,CAAC,MAAM,CAAC,CAAC,gBAAgB,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC,CACvD,CAAC,MAAM,EAAE;MAEV,IAAM,SAAS,GAAG,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC;MAEjD,OAAO,IAAI,qBAAA,CAAA,mBAAmB,CAAC;QAC3B,OAAO,EAAE,WAAA,CAAA,gBAAgB;QACzB,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC;QACzC,MAAM,EAAE,WAAA,CAAA,eAAe;QACvB,UAAU,EAAE,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC;QACzD,GAAG,EAAE,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC;QAC9B,UAAU,EAAE;UACR,SAAS,EAAE,eAAe,CAAC,GAAG,EAAE;UAChC,eAAe,EAAE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC;UAC/D,gBAAgB,EAAE,aAAa,CAAC,iBAAiB,EAAE,CAAC,GAAG;QAC1D;OACJ,CAAC;IACN;EAAC;EAAA,OAAA,eAAA;AAAA;AAtCL,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PubkeyEncryptor = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst ed2curve_1 = __importDefault(require(\"ed2curve\"));\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst constants_1 = require(\"./constants\");\nconst x25519EncryptedData_1 = require(\"./x25519EncryptedData\");\nclass PubkeyEncryptor {\n    static encrypt(data, recipientPubKey, authSecretKey) {\n        // create a new x25519 keypair that will be used for EDH\n        const edhPair = tweetnacl_1.default.sign.keyPair();\n        const recipientDHPubKey = ed2curve_1.default.convertPublicKey(recipientPubKey.valueOf());\n        if (recipientDHPubKey === null) {\n            throw new Error(\"Could not convert ed25519 public key to x25519\");\n        }\n        const edhConvertedSecretKey = ed2curve_1.default.convertSecretKey(edhPair.secretKey);\n        // For the nonce we use a random component and a deterministic one based on the message\n        //  - this is so we won't completely rely on the random number generator\n        const nonceDeterministic = crypto_1.default.createHash('sha256').update(data).digest().slice(0, constants_1.PubKeyEncNonceLength / 2);\n        const nonceRandom = tweetnacl_1.default.randomBytes(constants_1.PubKeyEncNonceLength / 2);\n        const nonce = Buffer.concat([nonceDeterministic, nonceRandom]);\n        const encryptedMessage = tweetnacl_1.default.box(data, nonce, recipientDHPubKey, edhConvertedSecretKey);\n        // Note that the ciphertext is already authenticated for the ephemeral key - but we want it authenticated by\n        //  the ed25519 key which the user interacts with. A signature over H(ciphertext | edhPubKey)\n        //  would be enough\n        const authMessage = crypto_1.default.createHash('sha256').update(Buffer.concat([encryptedMessage, edhPair.publicKey])).digest();\n        const signature = authSecretKey.sign(authMessage);\n        return new x25519EncryptedData_1.X25519EncryptedData({\n            version: constants_1.PubKeyEncVersion,\n            nonce: Buffer.from(nonce).toString('hex'),\n            cipher: constants_1.PubKeyEncCipher,\n            ciphertext: Buffer.from(encryptedMessage).toString('hex'),\n            mac: signature.toString('hex'),\n            identities: {\n                recipient: recipientPubKey.hex(),\n                ephemeralPubKey: Buffer.from(edhPair.publicKey).toString('hex'),\n                originatorPubKey: authSecretKey.generatePublicKey().hex(),\n            }\n        });\n    }\n}\nexports.PubkeyEncryptor = PubkeyEncryptor;\n//# sourceMappingURL=pubkeyEncryptor.js.map"]},"metadata":{},"sourceType":"script"}