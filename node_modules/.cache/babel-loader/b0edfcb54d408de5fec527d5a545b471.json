{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PubkeyDecryptor = void 0;\nvar crypto_1 = __importDefault(require(\"crypto\"));\nvar tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nvar ed2curve_1 = __importDefault(require(\"ed2curve\"));\nvar userKeys_1 = require(\"../userKeys\");\nvar PubkeyDecryptor = /*#__PURE__*/function () {\n  function PubkeyDecryptor() {\n    _classCallCheck(this, PubkeyDecryptor);\n  }\n  _createClass(PubkeyDecryptor, null, [{\n    key: \"decrypt\",\n    value: function decrypt(data, decryptorSecretKey) {\n      var ciphertext = Buffer.from(data.ciphertext, 'hex');\n      var edhPubKey = Buffer.from(data.identities.ephemeralPubKey, 'hex');\n      var originatorPubKeyBuffer = Buffer.from(data.identities.originatorPubKey, 'hex');\n      var originatorPubKey = new userKeys_1.UserPublicKey(originatorPubKeyBuffer);\n      var authMessage = crypto_1.default.createHash('sha256').update(Buffer.concat([ciphertext, edhPubKey])).digest();\n      if (!originatorPubKey.verify(authMessage, Buffer.from(data.mac, 'hex'))) {\n        throw new Error(\"Invalid authentication for encrypted message originator\");\n      }\n      var nonce = Buffer.from(data.nonce, 'hex');\n      var x25519Secret = ed2curve_1.default.convertSecretKey(decryptorSecretKey.valueOf());\n      var x25519EdhPubKey = ed2curve_1.default.convertPublicKey(edhPubKey);\n      if (x25519EdhPubKey === null) {\n        throw new Error(\"Could not convert ed25519 public key to x25519\");\n      }\n      var decryptedMessage = tweetnacl_1.default.box.open(ciphertext, nonce, x25519EdhPubKey, x25519Secret);\n      if (decryptedMessage === null) {\n        throw new Error(\"Failed authentication for given ciphertext\");\n      }\n      return Buffer.from(decryptedMessage);\n    }\n  }]);\n  return PubkeyDecryptor;\n}();\nexports.PubkeyDecryptor = PubkeyDecryptor;","map":{"version":3,"sources":["../../src/crypto/pubkeyDecryptor.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA;AACA,IAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;AACA,IAAA,UAAA,GAAA,eAAA,CAAA,OAAA,CAAA,UAAA,CAAA,CAAA;AAEA,IAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAA2D,IAE9C,eAAe;EAAA,SAAA,gBAAA;IAAA,eAAA,OAAA,eAAA;EAAA;EAAA,YAAA,CAAA,eAAA;IAAA,GAAA;IAAA,KAAA,EACxB,SAAA,QAAe,IAAyB,EAAE,kBAAiC,EAAA;MACvE,IAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC;MACtD,IAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,eAAe,EAAE,KAAK,CAAC;MACrE,IAAM,sBAAsB,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,gBAAgB,EAAE,KAAK,CAAC;MACnF,IAAM,gBAAgB,GAAG,IAAI,UAAA,CAAA,aAAa,CAAC,sBAAsB,CAAC;MAElE,IAAM,WAAW,GAAG,QAAA,CAAA,OAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAClD,MAAM,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC,CACzC,CAAC,MAAM,EAAE;MAEV,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,EAAE;QACrE,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC;MAC7E;MAED,IAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC;MAC5C,IAAM,YAAY,GAAG,UAAA,CAAA,OAAQ,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,OAAO,EAAE,CAAC;MAC5E,IAAM,eAAe,GAAG,UAAA,CAAA,OAAQ,CAAC,gBAAgB,CAAC,SAAS,CAAC;MAC5D,IAAI,eAAe,KAAK,IAAI,EAAE;QAC1B,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC;MACpE;MAED,IAAM,gBAAgB,GAAG,WAAA,CAAA,OAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,KAAK,EAAE,eAAe,EAAE,YAAY,CAAC;MACxF,IAAI,gBAAgB,KAAK,IAAI,EAAE;QAC3B,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC;MAChE;MAED,OAAO,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC;IACxC;EAAC;EAAA,OAAA,eAAA;AAAA;AA5BL,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PubkeyDecryptor = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst ed2curve_1 = __importDefault(require(\"ed2curve\"));\nconst userKeys_1 = require(\"../userKeys\");\nclass PubkeyDecryptor {\n    static decrypt(data, decryptorSecretKey) {\n        const ciphertext = Buffer.from(data.ciphertext, 'hex');\n        const edhPubKey = Buffer.from(data.identities.ephemeralPubKey, 'hex');\n        const originatorPubKeyBuffer = Buffer.from(data.identities.originatorPubKey, 'hex');\n        const originatorPubKey = new userKeys_1.UserPublicKey(originatorPubKeyBuffer);\n        const authMessage = crypto_1.default.createHash('sha256').update(Buffer.concat([ciphertext, edhPubKey])).digest();\n        if (!originatorPubKey.verify(authMessage, Buffer.from(data.mac, 'hex'))) {\n            throw new Error(\"Invalid authentication for encrypted message originator\");\n        }\n        const nonce = Buffer.from(data.nonce, 'hex');\n        const x25519Secret = ed2curve_1.default.convertSecretKey(decryptorSecretKey.valueOf());\n        const x25519EdhPubKey = ed2curve_1.default.convertPublicKey(edhPubKey);\n        if (x25519EdhPubKey === null) {\n            throw new Error(\"Could not convert ed25519 public key to x25519\");\n        }\n        const decryptedMessage = tweetnacl_1.default.box.open(ciphertext, nonce, x25519EdhPubKey, x25519Secret);\n        if (decryptedMessage === null) {\n            throw new Error(\"Failed authentication for given ciphertext\");\n        }\n        return Buffer.from(decryptedMessage);\n    }\n}\nexports.PubkeyDecryptor = PubkeyDecryptor;\n//# sourceMappingURL=pubkeyDecryptor.js.map"]},"metadata":{},"sourceType":"script"}