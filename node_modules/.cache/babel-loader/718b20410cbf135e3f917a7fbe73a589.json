{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserWallet = exports.UserWalletKind = void 0;\nvar crypto_1 = require(\"./crypto\");\nvar derivationParams_1 = require(\"./crypto/derivationParams\");\nvar errors_1 = require(\"./errors\");\nvar mnemonic_1 = require(\"./mnemonic\");\nvar userKeys_1 = require(\"./userKeys\");\nvar UserWalletKind;\n(function (UserWalletKind) {\n  UserWalletKind[\"SecretKey\"] = \"secretKey\";\n  UserWalletKind[\"Mnemonic\"] = \"mnemonic\";\n})(UserWalletKind = exports.UserWalletKind || (exports.UserWalletKind = {}));\nvar UserWallet = /*#__PURE__*/function () {\n  function UserWallet(_ref) {\n    var kind = _ref.kind,\n      encryptedData = _ref.encryptedData,\n      publicKeyWhenKindIsSecretKey = _ref.publicKeyWhenKindIsSecretKey;\n    _classCallCheck(this, UserWallet);\n    this.kind = kind;\n    this.encryptedData = encryptedData;\n    this.publicKeyWhenKindIsSecretKey = publicKeyWhenKindIsSecretKey;\n  }\n  _createClass(UserWallet, [{\n    key: \"toJSON\",\n    value:\n    /**\n     * Converts the encrypted keyfile to plain JavaScript object.\n     */\n    function toJSON() {\n      if (this.kind == UserWalletKind.SecretKey) {\n        return this.toJSONWhenKindIsSecretKey();\n      }\n      return this.toJSONWhenKindIsMnemonic();\n    }\n  }, {\n    key: \"toJSONWhenKindIsSecretKey\",\n    value: function toJSONWhenKindIsSecretKey() {\n      if (!this.publicKeyWhenKindIsSecretKey) {\n        throw new errors_1.Err(\"Public key isn't available\");\n      }\n      var cryptoSection = this.getCryptoSectionAsJSON();\n      var envelope = {\n        version: this.encryptedData.version,\n        kind: this.kind,\n        id: this.encryptedData.id,\n        address: this.publicKeyWhenKindIsSecretKey.hex(),\n        bech32: this.publicKeyWhenKindIsSecretKey.toAddress().toString(),\n        crypto: cryptoSection\n      };\n      return envelope;\n    }\n  }, {\n    key: \"getCryptoSectionAsJSON\",\n    value: function getCryptoSectionAsJSON() {\n      var cryptoSection = {\n        ciphertext: this.encryptedData.ciphertext,\n        cipherparams: {\n          iv: this.encryptedData.iv\n        },\n        cipher: crypto_1.CipherAlgorithm,\n        kdf: crypto_1.KeyDerivationFunction,\n        kdfparams: {\n          dklen: this.encryptedData.kdfparams.dklen,\n          salt: this.encryptedData.salt,\n          n: this.encryptedData.kdfparams.n,\n          r: this.encryptedData.kdfparams.r,\n          p: this.encryptedData.kdfparams.p\n        },\n        mac: this.encryptedData.mac\n      };\n      return cryptoSection;\n    }\n  }, {\n    key: \"toJSONWhenKindIsMnemonic\",\n    value: function toJSONWhenKindIsMnemonic() {\n      var cryptoSection = this.getCryptoSectionAsJSON();\n      return {\n        version: this.encryptedData.version,\n        id: this.encryptedData.id,\n        kind: this.kind,\n        crypto: cryptoSection\n      };\n    }\n  }], [{\n    key: \"fromSecretKey\",\n    value: function fromSecretKey(_ref2) {\n      var secretKey = _ref2.secretKey,\n        password = _ref2.password,\n        randomness = _ref2.randomness;\n      randomness = randomness || new crypto_1.Randomness();\n      var publicKey = secretKey.generatePublicKey();\n      var data = Buffer.concat([secretKey.valueOf(), publicKey.valueOf()]);\n      var encryptedData = crypto_1.Encryptor.encrypt(data, password, randomness);\n      return new UserWallet({\n        kind: UserWalletKind.SecretKey,\n        encryptedData: encryptedData,\n        publicKeyWhenKindIsSecretKey: publicKey\n      });\n    }\n  }, {\n    key: \"fromMnemonic\",\n    value: function fromMnemonic(_ref3) {\n      var mnemonic = _ref3.mnemonic,\n        password = _ref3.password,\n        randomness = _ref3.randomness;\n      randomness = randomness || new crypto_1.Randomness();\n      mnemonic_1.Mnemonic.assertTextIsValid(mnemonic);\n      var data = Buffer.from(mnemonic);\n      var encryptedData = crypto_1.Encryptor.encrypt(data, password, randomness);\n      return new UserWallet({\n        kind: UserWalletKind.Mnemonic,\n        encryptedData: encryptedData\n      });\n    }\n    /**\n     * Copied from: https://github.com/multiversx/mx-deprecated-core-js/blob/v1.28.0/src/account.js#L42\n     * Notes: adjustements (code refactoring, no change in logic), in terms of:\n     *  - typing (since this is the TypeScript version)\n     *  - error handling (in line with sdk-core's error system)\n     *  - references to crypto functions\n     *  - references to object members\n     *\n     * From an encrypted keyfile, given the password, loads the secret key and the public key.\n     */\n  }, {\n    key: \"decryptSecretKey\",\n    value: function decryptSecretKey(keyFileObject, password) {\n      // Here, we do not check the \"kind\" field. Older keystore files (holding only secret keys) do not have this field.\n      var encryptedData = UserWallet.edFromJSON(keyFileObject);\n      var text = crypto_1.Decryptor.decrypt(encryptedData, password);\n      while (text.length < 32) {\n        var zeroPadding = Buffer.from([0x00]);\n        text = Buffer.concat([zeroPadding, text]);\n      }\n      var seed = text.slice(0, 32);\n      return new userKeys_1.UserSecretKey(seed);\n    }\n  }, {\n    key: \"decryptMnemonic\",\n    value: function decryptMnemonic(keyFileObject, password) {\n      if (keyFileObject.kind != UserWalletKind.Mnemonic) {\n        throw new errors_1.Err(\"Expected kind to be \".concat(UserWalletKind.Mnemonic, \", but it was \").concat(keyFileObject.kind, \".\"));\n      }\n      var encryptedData = UserWallet.edFromJSON(keyFileObject);\n      var data = crypto_1.Decryptor.decrypt(encryptedData, password);\n      var mnemonic = mnemonic_1.Mnemonic.fromString(data.toString());\n      return mnemonic;\n    }\n  }, {\n    key: \"edFromJSON\",\n    value: function edFromJSON(keyfileObject) {\n      return new crypto_1.EncryptedData({\n        version: keyfileObject.version,\n        id: keyfileObject.id,\n        cipher: keyfileObject.crypto.cipher,\n        ciphertext: keyfileObject.crypto.ciphertext,\n        iv: keyfileObject.crypto.cipherparams.iv,\n        kdf: keyfileObject.crypto.kdf,\n        kdfparams: new derivationParams_1.ScryptKeyDerivationParams(keyfileObject.crypto.kdfparams.n, keyfileObject.crypto.kdfparams.r, keyfileObject.crypto.kdfparams.p, keyfileObject.crypto.kdfparams.dklen),\n        salt: keyfileObject.crypto.kdfparams.salt,\n        mac: keyfileObject.crypto.mac\n      });\n    }\n  }]);\n  return UserWallet;\n}();\nexports.UserWallet = UserWallet;","map":{"version":3,"sources":["../src/userWallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UserWallet = exports.UserWalletKind = void 0;\nconst crypto_1 = require(\"./crypto\");\nconst derivationParams_1 = require(\"./crypto/derivationParams\");\nconst errors_1 = require(\"./errors\");\nconst mnemonic_1 = require(\"./mnemonic\");\nconst userKeys_1 = require(\"./userKeys\");\nvar UserWalletKind;\n(function (UserWalletKind) {\n    UserWalletKind[\"SecretKey\"] = \"secretKey\";\n    UserWalletKind[\"Mnemonic\"] = \"mnemonic\";\n})(UserWalletKind = exports.UserWalletKind || (exports.UserWalletKind = {}));\nclass UserWallet {\n    constructor({ kind, encryptedData, publicKeyWhenKindIsSecretKey }) {\n        this.kind = kind;\n        this.encryptedData = encryptedData;\n        this.publicKeyWhenKindIsSecretKey = publicKeyWhenKindIsSecretKey;\n    }\n    static fromSecretKey({ secretKey, password, randomness }) {\n        randomness = randomness || new crypto_1.Randomness();\n        const publicKey = secretKey.generatePublicKey();\n        const data = Buffer.concat([secretKey.valueOf(), publicKey.valueOf()]);\n        const encryptedData = crypto_1.Encryptor.encrypt(data, password, randomness);\n        return new UserWallet({\n            kind: UserWalletKind.SecretKey,\n            encryptedData,\n            publicKeyWhenKindIsSecretKey: publicKey\n        });\n    }\n    static fromMnemonic({ mnemonic, password, randomness }) {\n        randomness = randomness || new crypto_1.Randomness();\n        mnemonic_1.Mnemonic.assertTextIsValid(mnemonic);\n        const data = Buffer.from(mnemonic);\n        const encryptedData = crypto_1.Encryptor.encrypt(data, password, randomness);\n        return new UserWallet({\n            kind: UserWalletKind.Mnemonic,\n            encryptedData\n        });\n    }\n    /**\n     * Copied from: https://github.com/multiversx/mx-deprecated-core-js/blob/v1.28.0/src/account.js#L42\n     * Notes: adjustements (code refactoring, no change in logic), in terms of:\n     *  - typing (since this is the TypeScript version)\n     *  - error handling (in line with sdk-core's error system)\n     *  - references to crypto functions\n     *  - references to object members\n     *\n     * From an encrypted keyfile, given the password, loads the secret key and the public key.\n     */\n    static decryptSecretKey(keyFileObject, password) {\n        // Here, we do not check the \"kind\" field. Older keystore files (holding only secret keys) do not have this field.\n        const encryptedData = UserWallet.edFromJSON(keyFileObject);\n        let text = crypto_1.Decryptor.decrypt(encryptedData, password);\n        while (text.length < 32) {\n            let zeroPadding = Buffer.from([0x00]);\n            text = Buffer.concat([zeroPadding, text]);\n        }\n        const seed = text.slice(0, 32);\n        return new userKeys_1.UserSecretKey(seed);\n    }\n    static decryptMnemonic(keyFileObject, password) {\n        if (keyFileObject.kind != UserWalletKind.Mnemonic) {\n            throw new errors_1.Err(`Expected kind to be ${UserWalletKind.Mnemonic}, but it was ${keyFileObject.kind}.`);\n        }\n        const encryptedData = UserWallet.edFromJSON(keyFileObject);\n        const data = crypto_1.Decryptor.decrypt(encryptedData, password);\n        const mnemonic = mnemonic_1.Mnemonic.fromString(data.toString());\n        return mnemonic;\n    }\n    static edFromJSON(keyfileObject) {\n        return new crypto_1.EncryptedData({\n            version: keyfileObject.version,\n            id: keyfileObject.id,\n            cipher: keyfileObject.crypto.cipher,\n            ciphertext: keyfileObject.crypto.ciphertext,\n            iv: keyfileObject.crypto.cipherparams.iv,\n            kdf: keyfileObject.crypto.kdf,\n            kdfparams: new derivationParams_1.ScryptKeyDerivationParams(keyfileObject.crypto.kdfparams.n, keyfileObject.crypto.kdfparams.r, keyfileObject.crypto.kdfparams.p, keyfileObject.crypto.kdfparams.dklen),\n            salt: keyfileObject.crypto.kdfparams.salt,\n            mac: keyfileObject.crypto.mac,\n        });\n    }\n    /**\n     * Converts the encrypted keyfile to plain JavaScript object.\n     */\n    toJSON() {\n        if (this.kind == UserWalletKind.SecretKey) {\n            return this.toJSONWhenKindIsSecretKey();\n        }\n        return this.toJSONWhenKindIsMnemonic();\n    }\n    toJSONWhenKindIsSecretKey() {\n        if (!this.publicKeyWhenKindIsSecretKey) {\n            throw new errors_1.Err(\"Public key isn't available\");\n        }\n        const cryptoSection = this.getCryptoSectionAsJSON();\n        const envelope = {\n            version: this.encryptedData.version,\n            kind: this.kind,\n            id: this.encryptedData.id,\n            address: this.publicKeyWhenKindIsSecretKey.hex(),\n            bech32: this.publicKeyWhenKindIsSecretKey.toAddress().toString(),\n            crypto: cryptoSection\n        };\n        return envelope;\n    }\n    getCryptoSectionAsJSON() {\n        const cryptoSection = {\n            ciphertext: this.encryptedData.ciphertext,\n            cipherparams: { iv: this.encryptedData.iv },\n            cipher: crypto_1.CipherAlgorithm,\n            kdf: crypto_1.KeyDerivationFunction,\n            kdfparams: {\n                dklen: this.encryptedData.kdfparams.dklen,\n                salt: this.encryptedData.salt,\n                n: this.encryptedData.kdfparams.n,\n                r: this.encryptedData.kdfparams.r,\n                p: this.encryptedData.kdfparams.p\n            },\n            mac: this.encryptedData.mac,\n        };\n        return cryptoSection;\n    }\n    toJSONWhenKindIsMnemonic() {\n        const cryptoSection = this.getCryptoSectionAsJSON();\n        return {\n            version: this.encryptedData.version,\n            id: this.encryptedData.id,\n            kind: this.kind,\n            crypto: cryptoSection\n        };\n    }\n}\nexports.UserWallet = UserWallet;\n//# sourceMappingURL=userWallet.js.map"]},"metadata":{},"sourceType":"script"}