{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _slicedToArray = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectProvider = void 0;\nvar client_1 = __importDefault(require(\"@walletconnect/client\"));\nvar constants_1 = require(\"./constants\");\nvar logger_1 = require(\"./logger\");\nvar errors_1 = require(\"./errors\");\nvar primitives_1 = require(\"./primitives\");\nvar userAddress_1 = require(\"./userAddress\");\nvar WalletConnectProvider = /*#__PURE__*/function () {\n  function WalletConnectProvider(walletConnectBridge, onClientConnect) {\n    _classCallCheck(this, WalletConnectProvider);\n    this.address = \"\";\n    this.signature = \"\";\n    this.walletConnectBridge = walletConnectBridge;\n    this.onClientConnect = onClientConnect;\n  }\n  /**\n   * Initiates wallet connect client.\n   */\n  _createClass(WalletConnectProvider, [{\n    key: \"init\",\n    value: function init() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this$walletConnector, account, _account$split, _account$split2, address, signature;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.walletConnector = new client_1.default({\n                bridge: this.walletConnectBridge\n              });\n              this.walletConnector.on(\"connect\", this.onConnect.bind(this));\n              this.walletConnector.on(\"session_update\", this.onDisconnect.bind(this));\n              this.walletConnector.on(\"disconnect\", this.onDisconnect.bind(this));\n              if (!(this.walletConnector.connected && this.walletConnector.accounts.length)) {\n                _context.next = 9;\n                break;\n              }\n              _this$walletConnector = _slicedToArray(this.walletConnector.accounts, 1), account = _this$walletConnector[0];\n              _account$split = account.split(\".\"), _account$split2 = _slicedToArray(_account$split, 2), address = _account$split2[0], signature = _account$split2[1];\n              _context.next = 9;\n              return this.loginAccount(address, signature);\n            case 9:\n              return _context.abrupt(\"return\", true);\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      return !!this.walletConnector;\n    }\n    /**\n     * Returns true if provider is connected and a valid account is set\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var _this = this;\n      return new Promise(function (resolve, _) {\n        var _a;\n        return resolve(Boolean(_this.isInitialized() && ((_a = _this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) && _this.address));\n      });\n    }\n  }, {\n    key: \"login\",\n    value: function login() {\n      var _a, _b, _c, _d;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.walletConnector) {\n                _context2.next = 3;\n                break;\n              }\n              _context2.next = 3;\n              return this.init();\n            case 3:\n              if (!((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected)) {\n                _context2.next = 8;\n                break;\n              }\n              _context2.next = 6;\n              return this.walletConnector.killSession();\n            case 6:\n              logger_1.Logger.trace(\"WalletConnect login started but walletConnect not initialized\");\n              return _context2.abrupt(\"return\", \"\");\n            case 8:\n              _context2.next = 10;\n              return (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.createSession({\n                chainId: constants_1.WALLETCONNECT_MULTIVERSX_CHAIN_ID\n              });\n            case 10:\n              if ((_c = this.walletConnector) === null || _c === void 0 ? void 0 : _c.uri) {\n                _context2.next = 12;\n                break;\n              }\n              return _context2.abrupt(\"return\", \"\");\n            case 12:\n              return _context2.abrupt(\"return\", (_d = this.walletConnector) === null || _d === void 0 ? void 0 : _d.uri);\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n  }, {\n    key: \"logout\",\n    value: function logout() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this.walletConnector) {\n                _context3.next = 3;\n                break;\n              }\n              logger_1.Logger.error(\"logout: Wallet Connect not initialised, call init() first\");\n              throw new Error(\"Wallet Connect not initialised, call init() first\");\n            case 3:\n              if (!this.walletConnector.connected) {\n                _context3.next = 6;\n                break;\n              }\n              _context3.next = 6;\n              return (_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.killSession();\n            case 6:\n              return _context3.abrupt(\"return\", true);\n            case 7:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Fetches the wallet connect address\n     */\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this.walletConnector) {\n                _context4.next = 3;\n                break;\n              }\n              logger_1.Logger.error(\"getAddress: Wallet Connect not initialised, call init() first\");\n              throw new Error(\"Wallet Connect not initialised, call init() first\");\n            case 3:\n              return _context4.abrupt(\"return\", this.address);\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Fetches the wallet connect signature\n     */\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (this.walletConnector) {\n                _context5.next = 3;\n                break;\n              }\n              logger_1.Logger.error(\"getSignature: Wallet Connect not initialised, call init() first\");\n              throw new Error(\"Wallet Connect not initialised, call init() first\");\n            case 3:\n              return _context5.abrupt(\"return\", this.signature);\n            case 4:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(_) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              throw new errors_1.ErrNotImplemented();\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6);\n      }));\n    }\n    /**\n     * Signs a transaction and returns it\n     * @param transaction\n     */\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var address, sig;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (this.walletConnector) {\n                _context7.next = 3;\n                break;\n              }\n              logger_1.Logger.error(\"signTransaction: Wallet Connect not initialised, call init() first\");\n              throw new Error(\"Wallet Connect not initialised, call init() first\");\n            case 3:\n              _context7.next = 5;\n              return this.getAddress();\n            case 5:\n              address = _context7.sent;\n              _context7.next = 8;\n              return this.walletConnector.sendCustomRequest({\n                method: \"erd_sign\",\n                params: this.prepareWalletConnectMessage(transaction, address)\n              });\n            case 8:\n              sig = _context7.sent;\n              if (!(!sig || !sig.signature)) {\n                _context7.next = 12;\n                break;\n              }\n              logger_1.Logger.error(\"signTransaction: Wallet Connect could not sign the transaction\");\n              throw new Error(\"Wallet Connect could not sign the transaction\");\n            case 12:\n              transaction.applySignature(primitives_1.Signature.fromHex(sig.signature), userAddress_1.UserAddress.fromBech32(address));\n              return _context7.abrupt(\"return\", transaction);\n            case 14:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Signs an array of transactions and returns it\n     * @param transactions\n     */\n  }, {\n    key: \"signTransactions\",\n    value: function signTransactions(transactions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _this2 = this;\n        var signedTransaction, address, params, signatures, _iterator, _step, _step$value, index, transaction;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!(transactions.length === 1)) {\n                _context8.next = 5;\n                break;\n              }\n              _context8.next = 3;\n              return this.signTransaction(transactions[0]);\n            case 3:\n              signedTransaction = _context8.sent;\n              return _context8.abrupt(\"return\", [signedTransaction]);\n            case 5:\n              if (this.walletConnector) {\n                _context8.next = 8;\n                break;\n              }\n              logger_1.Logger.error(\"signTransactions: Wallet Connect not initialised, call init() first\");\n              throw new Error(\"Wallet Connect not initialised, call init() first\");\n            case 8:\n              _context8.next = 10;\n              return this.getAddress();\n            case 10:\n              address = _context8.sent;\n              params = transactions.map(function (transaction) {\n                return _this2.prepareWalletConnectMessage(transaction, address);\n              });\n              _context8.next = 14;\n              return this.walletConnector.sendCustomRequest({\n                method: \"erd_batch_sign\",\n                params: params\n              });\n            case 14:\n              signatures = _context8.sent;\n              if (!(!signatures || !Array.isArray(signatures))) {\n                _context8.next = 18;\n                break;\n              }\n              logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions\");\n              throw new Error(\"Wallet Connect could not sign the transactions\");\n            case 18:\n              if (!(transactions.length !== signatures.length)) {\n                _context8.next = 21;\n                break;\n              }\n              logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions. Invalid signatures.\");\n              throw new Error(\"Wallet Connect could not sign the transactions. Invalid signatures.\");\n            case 21:\n              _iterator = _createForOfIteratorHelper(transactions.entries());\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], transaction = _step$value[1];\n                  transaction.applySignature(primitives_1.Signature.fromHex(signatures[index].signature), userAddress_1.UserAddress.fromBech32(address));\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              return _context8.abrupt(\"return\", transactions);\n            case 24:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Sends a custom method and params and returns the response object\n     */\n  }, {\n    key: \"sendCustomMessage\",\n    value: function sendCustomMessage(_ref) {\n      var method = _ref.method,\n        params = _ref.params;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var customMessageResponse;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (this.walletConnector) {\n                _context9.next = 3;\n                break;\n              }\n              logger_1.Logger.error(\"sendCustomMessage: Wallet Connect not initialised, call init() first\");\n              throw new Error(\"Wallet Connect not initialised, call init() first\");\n            case 3:\n              _context9.next = 5;\n              return this.walletConnector.sendCustomRequest({\n                method: method,\n                params: params\n              });\n            case 5:\n              customMessageResponse = _context9.sent;\n              if (customMessageResponse) {\n                _context9.next = 9;\n                break;\n              }\n              logger_1.Logger.error(\"sendCustomMessage: Wallet Connect could not send the message\");\n              throw new Error(\"Wallet Connect could not send the message\");\n            case 9:\n              return _context9.abrupt(\"return\", customMessageResponse);\n            case 10:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n    }\n  }, {\n    key: \"onConnect\",\n    value: function onConnect(error, _ref2) {\n      var params = _ref2.params;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _params$0$accounts, account, _account$split3, _account$split4, address, signature;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              if (!error) {\n                _context10.next = 2;\n                break;\n              }\n              throw error;\n            case 2:\n              if (!(!params || !params[0])) {\n                _context10.next = 5;\n                break;\n              }\n              logger_1.Logger.error(\"Wallet Connect missing payload\");\n              throw new Error(\"missing payload\");\n            case 5:\n              _params$0$accounts = _slicedToArray(params[0].accounts, 1), account = _params$0$accounts[0];\n              _account$split3 = account.split(\".\"), _account$split4 = _slicedToArray(_account$split3, 2), address = _account$split4[0], signature = _account$split4[1];\n              _context10.next = 9;\n              return this.loginAccount(address, signature);\n            case 9:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n    }\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(error) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (!error) {\n                _context11.next = 2;\n                break;\n              }\n              throw error;\n            case 2:\n              this.onClientConnect.onClientLogout();\n            case 3:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n    }\n  }, {\n    key: \"loginAccount\",\n    value: function loginAccount(address, signature) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!this.addressIsValid(address)) {\n                _context12.next = 5;\n                break;\n              }\n              this.address = address;\n              if (signature) {\n                this.signature = signature;\n              }\n              this.onClientConnect.onClientLogin();\n              return _context12.abrupt(\"return\");\n            case 5:\n              logger_1.Logger.error(\"Wallet Connect invalid address \".concat(address));\n              if (!((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected)) {\n                _context12.next = 9;\n                break;\n              }\n              _context12.next = 9;\n              return (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession();\n            case 9:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n    }\n  }, {\n    key: \"prepareWalletConnectMessage\",\n    value: function prepareWalletConnectMessage(transaction, address) {\n      return {\n        nonce: transaction.getNonce().valueOf(),\n        from: address,\n        to: transaction.getReceiver().toString(),\n        amount: transaction.getValue().toString(),\n        gasPrice: transaction.getGasPrice().valueOf().toString(),\n        gasLimit: transaction.getGasLimit().valueOf().toString(),\n        data: Buffer.from(transaction.getData().toString().trim()).toString(),\n        chainId: transaction.getChainID().valueOf(),\n        version: transaction.getVersion().valueOf()\n      };\n    }\n  }, {\n    key: \"addressIsValid\",\n    value: function addressIsValid(destinationAddress) {\n      try {\n        var addr = userAddress_1.UserAddress.fromBech32(destinationAddress);\n        return !!addr;\n      } catch (_a) {\n        return false;\n      }\n    }\n  }]);\n  return WalletConnectProvider;\n}();\nexports.WalletConnectProvider = WalletConnectProvider;","map":{"version":3,"sources":["../src/walletConnectProvider.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,eAAA,CAAA,OAAA,CAAA,uBAAA,CAAA,CAAA;AAEA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAA4C,IAO/B,qBAAqB;EAO9B,SAAA,sBAAY,mBAA2B,EAAE,eAA+B,EAAA;IAAA,eAAA,OAAA,qBAAA;IALxE,IAAA,CAAA,OAAO,GAAW,EAAE;IACpB,IAAA,CAAA,SAAS,GAAW,EAAE;IAKlB,IAAI,CAAC,mBAAmB,GAAG,mBAAmB;IAC9C,IAAI,CAAC,eAAe,GAAG,eAAe;EAC1C;EAEA;;AAEG;EAFH,YAAA,CAAA,qBAAA;IAAA,GAAA;IAAA,KAAA,EAGM,SAAA,KAAA,EAAI;;;;;;cACN,IAAI,CAAC,eAAe,GAAG,IAAI,QAAA,CAAA,OAAY,CAAC;gBACpC,MAAM,EAAE,IAAI,CAAC;eAChB,CAAC;cACF,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;cAC7D,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,gBAAgB,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;cACvE,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,YAAY,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;cAAC,MAGlE,IAAI,CAAC,eAAe,CAAC,SAAS,IAC9B,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,MAAM;gBAAA,QAAA,CAAA,IAAA;gBAAA;cAAA;cAAA,qBAAA,GAAA,cAAA,CAEhB,IAAI,CAAC,eAAe,CAAC,QAAQ,MAAxC,OAAO,GAAA,qBAAA;cAAA,cAAA,GACe,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,EAAA,eAAA,GAAA,cAAA,CAAA,cAAA,MAAxC,OAAO,GAAA,eAAA,KAAE,SAAS,GAAA,eAAA;cAAA,QAAA,CAAA,IAAA;cACzB,OAAM,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,SAAS,CAAC;YAAA;cAAA,OAAA,QAAA,CAAA,MAAA,WAGxC,IAAI;YAAA;YAAA;cAAA,OAAA,QAAA,CAAA,IAAA;UAAA;QAAA,GAAA,OAAA;MAAA,CACd,EAAA;IAAA;IAED;;AAEG;EAFH;IAAA,GAAA;IAAA,KAAA,EAGA,SAAA,cAAA,EAAa;MACT,OAAO,CAAC,CAAC,IAAI,CAAC,eAAe;IACjC;IAEA;;AAEG;EAFH;IAAA,GAAA;IAAA,KAAA,EAGA,SAAA,YAAA,EAAW;MAAA,IAAA,KAAA;MACP,OAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,CAAC,EAAI;;QAChC,OAAA,OAAO,CACL,OAAO,CACH,KAAI,CAAC,aAAa,EAAE,K,MACjB,KAAI,CAAC,eAAe,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,SAAS,CAAA,IAC/B,KAAI,CAAC,OAAO,CAClB,CACF;OAAA,CACF;IACL;EAAC;IAAA,GAAA;IAAA,KAAA,EAEK,SAAA,MAAA,EAAK;;;;;;kBACF,IAAI,CAAC,eAAe;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cAAA,SAAA,CAAA,IAAA;cACrB,OAAM,IAAI,CAAC,IAAI,EAAE;YAAA;cAAA,MAGrB,CAAA,EAAA,GAAI,IAAI,CAAC,eAAe,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,SAAS;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cAAA,SAAA,CAAA,IAAA;cAC/B,OAAM,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE;YAAA;cACxC,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,+DAA+D,CAAC;cAAC,OAAA,SAAA,CAAA,MAAA,WACvE,EAAE;YAAA;cAAA,SAAA,CAAA,IAAA;cAGb,OAAA,CAAA,EAAA,GAAM,IAAI,CAAC,eAAe,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,aAAa,CAAC;gBAAE,OAAO,EAAE,WAAA,CAAA;cAAiC,CAAE,CAAA;YAAC;cAAA,IACrF,CAAA,EAAA,GAAC,IAAI,CAAC,eAAe,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cAAA,OAAA,SAAA,CAAA,MAAA,WAAW,EAAE;YAAA;cAAA,OAAA,SAAA,CAAA,MAAA,WAC3C,CAAA,EAAA,GAAO,IAAI,CAAC,eAAe,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,GAAG;YAAA;YAAA;cAAA,OAAA,SAAA,CAAA,IAAA;UAAA;QAAA,GAAA,QAAA;MAAA,C;IACnC;IAED;;AAEG;EAFH;IAAA,GAAA;IAAA,KAAA,EAGM,SAAA,OAAA,EAAM;;;;;;kBACH,IAAI,CAAC,eAAe;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACrB,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,2DAA2D,CAAC;cAAC,MACpE,IAAI,KAAK,CAAC,mDAAmD,CAAC;YAAA;cAAA,KAEpE,IAAI,CAAC,eAAe,CAAC,SAAS;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cAAA,SAAA,CAAA,IAAA;cAC9B,OAAA,CAAA,EAAA,GAAM,IAAI,CAAC,eAAe,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,WAAW,EAAA;YAAE;cAAA,OAAA,SAAA,CAAA,MAAA,WAEtC,IAAI;YAAA;YAAA;cAAA,OAAA,SAAA,CAAA,IAAA;UAAA;QAAA,GAAA,QAAA;MAAA,C;IACd;IAED;;AAEG;EAFH;IAAA,GAAA;IAAA,KAAA,EAGM,SAAA,WAAA,EAAU;;;;;kBACP,IAAI,CAAC,eAAe;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACrB,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,+DAA+D,CAAC;cAAC,MACxE,IAAI,KAAK,CAAC,mDAAmD,CAAC;YAAA;cAAA,OAAA,SAAA,CAAA,MAAA,WAGjE,IAAI,CAAC,OAAO;YAAA;YAAA;cAAA,OAAA,SAAA,CAAA,IAAA;UAAA;QAAA,GAAA,QAAA;MAAA,CACtB,EAAA;IAAA;IAED;;AAEG;EAFH;IAAA,GAAA;IAAA,KAAA,EAGM,SAAA,aAAA,EAAY;;;;;kBACT,IAAI,CAAC,eAAe;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACrB,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,iEAAiE,CAAC;cAAC,MAC1E,IAAI,KAAK,CAAC,mDAAmD,CAAC;YAAA;cAAA,OAAA,SAAA,CAAA,MAAA,WAGjE,IAAI,CAAC,SAAS;YAAA;YAAA;cAAA,OAAA,SAAA,CAAA,IAAA;UAAA;QAAA,GAAA,QAAA;MAAA,CACxB,EAAA;;EAAA;IAAA,GAAA;IAAA,KAAA,EAEK,SAAA,YAAwC,CAAI,EAAA;;;;;oBACxC,IAAI,QAAA,CAAA,iBAAiB,EAAE;YAAA;YAAA;cAAA,OAAA,SAAA,CAAA,IAAA;UAAA;QAAA,GAAA,QAAA;MAAA,CAChC,EAAA;IAAA;IAED;;;AAGG;EAHH;IAAA,GAAA;IAAA,KAAA,EAIM,SAAA,gBAAwC,WAAc,EAAA;;;;;;kBACnD,IAAI,CAAC,eAAe;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACrB,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,oEAAoE,CAAC;cAAC,MAC7E,IAAI,KAAK,CAAC,mDAAmD,CAAC;YAAA;cAAA,SAAA,CAAA,IAAA;cAGxD,OAAM,IAAI,CAAC,UAAU,EAAE;YAAA;cAAjC,OAAO,GAAA,SAAA,CAAA,IAAA;cAAA,SAAA,CAAA,IAAA;cACD,OAAM,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC;gBACrD,MAAM,EAAE,UAAU;gBAClB,MAAM,EAAE,IAAI,CAAC,2BAA2B,CAAC,WAAW,EAAE,OAAO;eAChE,CAAC;YAAA;cAHI,GAAG,GAAA,SAAA,CAAA,IAAA;cAAA,MAIL,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACtB,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,gEAAgE,CAAC;cAAC,MACzE,IAAI,KAAK,CAAC,+CAA+C,CAAC;YAAA;cAGpE,WAAW,CAAC,cAAc,CAAC,YAAA,CAAA,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,aAAA,CAAA,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;cAAC,OAAA,SAAA,CAAA,MAAA,WACvF,WAAW;YAAA;YAAA;cAAA,OAAA,SAAA,CAAA,IAAA;UAAA;QAAA,GAAA,QAAA;MAAA,CACrB,EAAA;IAAA;IAED;;;AAGG;EAHH;IAAA,GAAA;IAAA,KAAA,EAIM,SAAA,iBAAyC,YAAiB,EAAA;;;;;;;oBACzD,YAAY,CAAC,MAAM,KAAK,CAAC;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cAAA,SAAA,CAAA,IAAA;cACE,OAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;YAAA;cAA/D,iBAAiB,GAAA,SAAA,CAAA,IAAA;cAAA,OAAA,SAAA,CAAA,MAAA,WAChB,CAAC,iBAAiB,CAAC;YAAA;cAAA,IAGzB,IAAI,CAAC,eAAe;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACrB,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,qEAAqE,CAAC;cAAC,MAC9E,IAAI,KAAK,CAAC,mDAAmD,CAAC;YAAA;cAAA,SAAA,CAAA,IAAA;cAGxD,OAAM,IAAI,CAAC,UAAU,EAAE;YAAA;cAAjC,OAAO,GAAA,SAAA,CAAA,IAAA;cACP,MAAM,GAAG,YAAY,CAAC,GAAG,CAAC,UAAC,WAAW;gBAAA,OAAK,MAAI,CAAC,2BAA2B,CAAC,WAAW,EAAE,OAAO,CAAC;cAAA,EAAC;cAAA,SAAA,CAAA,IAAA;cACpC,OAAM,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC;gBAC7G,MAAM,EAAE,gBAAgB;gBACxB,MAAM,EAAN;eACH,CAAC;YAAA;cAHI,UAAU,GAAA,SAAA,CAAA,IAAA;cAAA,MAIZ,CAAC,UAAU,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACzC,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,kEAAkE,CAAC;cAAC,MAC3E,IAAI,KAAK,CAAC,gDAAgD,CAAC;YAAA;cAAA,MAGjE,YAAY,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACzC,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,uFAAuF,CAAC;cAAC,MAChG,IAAI,KAAK,CAAC,qEAAqE,CAAC;YAAA;cAAA,SAAA,GAAA,0BAAA,CAGvD,YAAY,CAAC,OAAO,EAAE;cAAA;gBAAzD,KAAA,SAAA,CAAA,CAAA,MAAA,KAAA,GAAA,SAAA,CAAA,CAAA,IAAA,IAAA,GAA2D;kBAAA,WAAA,GAAA,cAAA,CAAA,KAAA,CAAA,KAAA,MAA/C,KAAK,GAAA,WAAA,KAAE,WAAW,GAAA,WAAA;kBAC1B,WAAW,CAAC,cAAc,CAAC,YAAA,CAAA,SAAS,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,EAAE,aAAA,CAAA,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;;cAC9G,SAAA,GAAA;gBAAA,SAAA,CAAA,CAAA,CAAA,GAAA;cAAA;gBAAA,SAAA,CAAA,CAAA;cAAA;cAAA,OAAA,SAAA,CAAA,MAAA,WAEM,YAAY;YAAA;YAAA;cAAA,OAAA,SAAA,CAAA,IAAA;UAAA;QAAA,GAAA,QAAA;MAAA,CACtB,EAAA;IAAA;IAED;;AAEG;EAFH;IAAA,GAAA;IAAA,KAAA,EAGM,SAAA,kBAAA,IAAA,EAML;MAAA,IALG,MAAM,GAAA,IAAA,CAAN,MAAM;QACN,MAAM,GAAA,IAAA,CAAN,MAAM;;;;;;kBAKD,IAAI,CAAC,eAAe;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACrB,QAAA,CAAA,MAAM,CAAC,KAAK,CACR,sEAAsE,CACzE;cAAC,MACI,IAAI,KAAK,CAAC,mDAAmD,CAAC;YAAA;cAAA,SAAA,CAAA,IAAA;cAE1C,OAAM,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC;gBACvE,MAAM,EAAN,MAAM;gBACN,MAAM,EAAN;eACH,CAAC;YAAA;cAHI,qBAAqB,GAAA,SAAA,CAAA,IAAA;cAAA,IAKtB,qBAAqB;gBAAA,SAAA,CAAA,IAAA;gBAAA;cAAA;cACtB,QAAA,CAAA,MAAM,CAAC,KAAK,CACR,8DAA8D,CACjE;cAAC,MACI,IAAI,KAAK,CAAC,2CAA2C,CAAC;YAAA;cAAA,OAAA,SAAA,CAAA,MAAA,WAGzD,qBAAqB;YAAA;YAAA;cAAA,OAAA,SAAA,CAAA,IAAA;UAAA;QAAA,GAAA,QAAA;MAAA,CAC/B,EAAA;;EAAA;IAAA,GAAA;IAAA,KAAA,EAEa,SAAA,UAAU,KAAU,EAAA,KAAA,EAAiB;MAAA,IAAb,MAAM,GAAA,KAAA,CAAN,MAAM;;;;;;mBACpC,KAAK;gBAAA,UAAA,CAAA,IAAA;gBAAA;cAAA;cAAA,MACC,KAAK;YAAA;cAAA,MAEX,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;gBAAA,UAAA,CAAA,IAAA;gBAAA;cAAA;cACrB,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC,gCAAgC,CAAC;cAAC,MACzC,IAAI,KAAK,CAAC,iBAAiB,CAAC;YAAA;cAAA,kBAAA,GAAA,cAAA,CAIlC,MAAM,CAAC,CAAC,CAAC,CADT,QAAQ,MAAG,OAAO,GAAA,kBAAA;cAAA,eAAA,GAGO,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,EAAA,eAAA,GAAA,cAAA,CAAA,eAAA,MAAxC,OAAO,GAAA,eAAA,KAAE,SAAS,GAAA,eAAA;cAAA,UAAA,CAAA,IAAA;cACzB,OAAM,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,SAAS,CAAC;YAAA;YAAA;cAAA,OAAA,UAAA,CAAA,IAAA;UAAA;QAAA,GAAA,SAAA;MAAA,CAC9C,EAAA;;EAAA;IAAA,GAAA;IAAA,KAAA,EAEa,SAAA,aAAa,KAAU,EAAA;;;;;mBAC7B,KAAK;gBAAA,UAAA,CAAA,IAAA;gBAAA;cAAA;cAAA,MACC,KAAK;YAAA;cAEf,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE;YAAC;YAAA;cAAA,OAAA,UAAA,CAAA,IAAA;UAAA;QAAA,GAAA,SAAA;MAAA,CACzC,EAAA;;EAAA;IAAA,GAAA;IAAA,KAAA,EAEa,SAAA,aAAa,OAAe,EAAE,SAAkB,EAAA;;;;;;mBACtD,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC;gBAAA,UAAA,CAAA,IAAA;gBAAA;cAAA;cAC5B,IAAI,CAAC,OAAO,GAAG,OAAO;cACtB,IAAI,SAAS,EAAE;gBACX,IAAI,CAAC,SAAS,GAAG,SAAS;cAC7B;cACD,IAAI,CAAC,eAAe,CAAC,aAAa,EAAE;cAAC,OAAA,UAAA,CAAA,MAAA;YAAA;cAIzC,QAAA,CAAA,MAAM,CAAC,KAAK,mCAAA,MAAA,CAAmC,OAAO,EAAG;cAAC,MAC1D,CAAA,EAAA,GAAI,IAAI,CAAC,eAAe,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,SAAS;gBAAA,UAAA,CAAA,IAAA;gBAAA;cAAA;cAAA,UAAA,CAAA,IAAA;cAC/B,OAAA,CAAA,EAAA,GAAM,IAAI,CAAC,eAAe,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,WAAW,EAAA;YAAE;YAAA;cAAA,OAAA,UAAA,CAAA,IAAA;UAAA;QAAA,GAAA,SAAA;MAAA,C;;EAEhD;IAAA,GAAA;IAAA,KAAA,EAEO,SAAA,4BAA4B,WAAyB,EAAE,OAAe,EAAA;MAC1E,OAAO;QACH,KAAK,EAAE,WAAW,CAAC,QAAQ,EAAE,CAAC,OAAO,EAAE;QACvC,IAAI,EAAE,OAAO;QACb,EAAE,EAAE,WAAW,CAAC,WAAW,EAAE,CAAC,QAAQ,EAAE;QACxC,MAAM,EAAE,WAAW,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE;QACzC,QAAQ,EAAE,WAAW,CAChB,WAAW,EAAE,CACb,OAAO,EAAE,CACT,QAAQ,EAAE;QACf,QAAQ,EAAE,WAAW,CAChB,WAAW,EAAE,CACb,OAAO,EAAE,CACT,QAAQ,EAAE;QACf,IAAI,EAAE,MAAM,CAAC,IAAI,CACb,WAAW,CACN,OAAO,EAAE,CACT,QAAQ,EAAE,CACV,IAAI,EAAE,CACd,CAAC,QAAQ,EAAE;QACZ,OAAO,EAAE,WAAW,CAAC,UAAU,EAAE,CAAC,OAAO,EAAE;QAC3C,OAAO,EAAE,WAAW,CAAC,UAAU,EAAE,CAAC,OAAO;OAC5C;IACL;EAAC;IAAA,GAAA;IAAA,KAAA,EAEO,SAAA,eAAe,kBAA0B,EAAA;MAC7C,IAAI;QACA,IAAM,IAAI,GAAG,aAAA,CAAA,WAAW,CAAC,UAAU,CAAC,kBAAkB,CAAC;QACvD,OAAO,CAAC,CAAC,IAAI;OAChB,CAAC,OAAA,EAAA,EAAM;QACJ,OAAO,KAAK;MACf;IACL;EAAC;EAAA,OAAA,qBAAA;AAAA;AAvRL,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletConnectProvider = void 0;\nconst client_1 = __importDefault(require(\"@walletconnect/client\"));\nconst constants_1 = require(\"./constants\");\nconst logger_1 = require(\"./logger\");\nconst errors_1 = require(\"./errors\");\nconst primitives_1 = require(\"./primitives\");\nconst userAddress_1 = require(\"./userAddress\");\nclass WalletConnectProvider {\n    constructor(walletConnectBridge, onClientConnect) {\n        this.address = \"\";\n        this.signature = \"\";\n        this.walletConnectBridge = walletConnectBridge;\n        this.onClientConnect = onClientConnect;\n    }\n    /**\n     * Initiates wallet connect client.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.walletConnector = new client_1.default({\n                bridge: this.walletConnectBridge,\n            });\n            this.walletConnector.on(\"connect\", this.onConnect.bind(this));\n            this.walletConnector.on(\"session_update\", this.onDisconnect.bind(this));\n            this.walletConnector.on(\"disconnect\", this.onDisconnect.bind(this));\n            if (this.walletConnector.connected &&\n                this.walletConnector.accounts.length) {\n                const [account] = this.walletConnector.accounts;\n                const [address, signature] = account.split(\".\");\n                yield this.loginAccount(address, signature);\n            }\n            return true;\n        });\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n    isInitialized() {\n        return !!this.walletConnector;\n    }\n    /**\n     * Returns true if provider is connected and a valid account is set\n     */\n    isConnected() {\n        return new Promise((resolve, _) => {\n            var _a;\n            return resolve(Boolean(this.isInitialized()\n                && ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected)\n                && this.address));\n        });\n    }\n    login() {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                yield this.init();\n            }\n            if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n                yield this.walletConnector.killSession();\n                logger_1.Logger.trace(\"WalletConnect login started but walletConnect not initialized\");\n                return \"\";\n            }\n            yield ((_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.createSession({ chainId: constants_1.WALLETCONNECT_MULTIVERSX_CHAIN_ID }));\n            if (!((_c = this.walletConnector) === null || _c === void 0 ? void 0 : _c.uri)) {\n                return \"\";\n            }\n            return (_d = this.walletConnector) === null || _d === void 0 ? void 0 : _d.uri;\n        });\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n    logout() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"logout: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            if (this.walletConnector.connected) {\n                yield ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.killSession());\n            }\n            return true;\n        });\n    }\n    /**\n     * Fetches the wallet connect address\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"getAddress: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            return this.address;\n        });\n    }\n    /**\n     * Fetches the wallet connect signature\n     */\n    getSignature() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"getSignature: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            return this.signature;\n        });\n    }\n    signMessage(_) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new errors_1.ErrNotImplemented();\n        });\n    }\n    /**\n     * Signs a transaction and returns it\n     * @param transaction\n     */\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"signTransaction: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            const address = yield this.getAddress();\n            const sig = yield this.walletConnector.sendCustomRequest({\n                method: \"erd_sign\",\n                params: this.prepareWalletConnectMessage(transaction, address)\n            });\n            if (!sig || !sig.signature) {\n                logger_1.Logger.error(\"signTransaction: Wallet Connect could not sign the transaction\");\n                throw new Error(\"Wallet Connect could not sign the transaction\");\n            }\n            transaction.applySignature(primitives_1.Signature.fromHex(sig.signature), userAddress_1.UserAddress.fromBech32(address));\n            return transaction;\n        });\n    }\n    /**\n     * Signs an array of transactions and returns it\n     * @param transactions\n     */\n    signTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (transactions.length === 1) {\n                const signedTransaction = yield this.signTransaction(transactions[0]);\n                return [signedTransaction];\n            }\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"signTransactions: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            const address = yield this.getAddress();\n            const params = transactions.map((transaction) => this.prepareWalletConnectMessage(transaction, address));\n            const signatures = yield this.walletConnector.sendCustomRequest({\n                method: \"erd_batch_sign\",\n                params\n            });\n            if (!signatures || !Array.isArray(signatures)) {\n                logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions\");\n                throw new Error(\"Wallet Connect could not sign the transactions\");\n            }\n            if (transactions.length !== signatures.length) {\n                logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions. Invalid signatures.\");\n                throw new Error(\"Wallet Connect could not sign the transactions. Invalid signatures.\");\n            }\n            for (const [index, transaction] of transactions.entries()) {\n                transaction.applySignature(primitives_1.Signature.fromHex(signatures[index].signature), userAddress_1.UserAddress.fromBech32(address));\n            }\n            return transactions;\n        });\n    }\n    /**\n     * Sends a custom method and params and returns the response object\n     */\n    sendCustomMessage({ method, params, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            const customMessageResponse = yield this.walletConnector.sendCustomRequest({\n                method,\n                params,\n            });\n            if (!customMessageResponse) {\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect could not send the message\");\n                throw new Error(\"Wallet Connect could not send the message\");\n            }\n            return customMessageResponse;\n        });\n    }\n    onConnect(error, { params }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (error) {\n                throw error;\n            }\n            if (!params || !params[0]) {\n                logger_1.Logger.error(\"Wallet Connect missing payload\");\n                throw new Error(\"missing payload\");\n            }\n            const { accounts: [account], } = params[0];\n            const [address, signature] = account.split(\".\");\n            yield this.loginAccount(address, signature);\n        });\n    }\n    onDisconnect(error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (error) {\n                throw error;\n            }\n            this.onClientConnect.onClientLogout();\n        });\n    }\n    loginAccount(address, signature) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.addressIsValid(address)) {\n                this.address = address;\n                if (signature) {\n                    this.signature = signature;\n                }\n                this.onClientConnect.onClientLogin();\n                return;\n            }\n            logger_1.Logger.error(`Wallet Connect invalid address ${address}`);\n            if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n                yield ((_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession());\n            }\n        });\n    }\n    prepareWalletConnectMessage(transaction, address) {\n        return {\n            nonce: transaction.getNonce().valueOf(),\n            from: address,\n            to: transaction.getReceiver().toString(),\n            amount: transaction.getValue().toString(),\n            gasPrice: transaction\n                .getGasPrice()\n                .valueOf()\n                .toString(),\n            gasLimit: transaction\n                .getGasLimit()\n                .valueOf()\n                .toString(),\n            data: Buffer.from(transaction\n                .getData()\n                .toString()\n                .trim()).toString(),\n            chainId: transaction.getChainID().valueOf(),\n            version: transaction.getVersion().valueOf(),\n        };\n    }\n    addressIsValid(destinationAddress) {\n        try {\n            const addr = userAddress_1.UserAddress.fromBech32(destinationAddress);\n            return !!addr;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n}\nexports.WalletConnectProvider = WalletConnectProvider;\n//# sourceMappingURL=walletConnectProvider.js.map"]},"metadata":{},"sourceType":"script"}