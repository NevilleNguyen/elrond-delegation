{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = exports.parseValidatorKeys = exports.parseValidatorKey = exports.parseUserKeys = exports.parseUserKey = void 0;\nvar errors_1 = require(\"./errors\");\nvar userKeys_1 = require(\"./userKeys\");\nvar validatorKeys_1 = require(\"./validatorKeys\");\nfunction parseUserKey(text) {\n  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var keys = parseUserKeys(text);\n  return keys[index];\n}\nexports.parseUserKey = parseUserKey;\nfunction parseUserKeys(text) {\n  // The user PEM files encode both the seed and the pubkey in their payloads.\n  var buffers = parse(text, userKeys_1.USER_SEED_LENGTH + userKeys_1.USER_PUBKEY_LENGTH);\n  return buffers.map(function (buffer) {\n    return new userKeys_1.UserSecretKey(buffer.slice(0, userKeys_1.USER_SEED_LENGTH));\n  });\n}\nexports.parseUserKeys = parseUserKeys;\nfunction parseValidatorKey(text) {\n  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var keys = parseValidatorKeys(text);\n  return keys[index];\n}\nexports.parseValidatorKey = parseValidatorKey;\nfunction parseValidatorKeys(text) {\n  var buffers = parse(text, validatorKeys_1.VALIDATOR_SECRETKEY_LENGTH);\n  return buffers.map(function (buffer) {\n    return new validatorKeys_1.ValidatorSecretKey(buffer);\n  });\n}\nexports.parseValidatorKeys = parseValidatorKeys;\nfunction parse(text, expectedLength) {\n  // Split by newlines, trim whitespace, then discard remaining empty lines.\n  var lines = text.split(/\\r?\\n/).map(function (line) {\n    return line.trim();\n  }).filter(function (line) {\n    return line.length > 0;\n  });\n  var buffers = [];\n  var linesAccumulator = [];\n  var _iterator = _createForOfIteratorHelper(lines),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var line = _step.value;\n      if (line.startsWith(\"-----BEGIN\")) {\n        linesAccumulator = [];\n      } else if (line.startsWith(\"-----END\")) {\n        var asBase64 = linesAccumulator.join(\"\");\n        var asHex = Buffer.from(asBase64, \"base64\").toString();\n        var asBytes = Buffer.from(asHex, \"hex\");\n        if (asBytes.length != expectedLength) {\n          throw new errors_1.ErrBadPEM(\"incorrect key length: expected \".concat(expectedLength, \", found \").concat(asBytes.length));\n        }\n        buffers.push(asBytes);\n        linesAccumulator = [];\n      } else {\n        linesAccumulator.push(line);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (linesAccumulator.length != 0) {\n    throw new errors_1.ErrBadPEM(\"incorrect file structure\");\n  }\n  return buffers;\n}\nexports.parse = parse;","map":{"version":3,"sources":["../src/pem.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = exports.parseValidatorKeys = exports.parseValidatorKey = exports.parseUserKeys = exports.parseUserKey = void 0;\nconst errors_1 = require(\"./errors\");\nconst userKeys_1 = require(\"./userKeys\");\nconst validatorKeys_1 = require(\"./validatorKeys\");\nfunction parseUserKey(text, index = 0) {\n    let keys = parseUserKeys(text);\n    return keys[index];\n}\nexports.parseUserKey = parseUserKey;\nfunction parseUserKeys(text) {\n    // The user PEM files encode both the seed and the pubkey in their payloads.\n    let buffers = parse(text, userKeys_1.USER_SEED_LENGTH + userKeys_1.USER_PUBKEY_LENGTH);\n    return buffers.map(buffer => new userKeys_1.UserSecretKey(buffer.slice(0, userKeys_1.USER_SEED_LENGTH)));\n}\nexports.parseUserKeys = parseUserKeys;\nfunction parseValidatorKey(text, index = 0) {\n    let keys = parseValidatorKeys(text);\n    return keys[index];\n}\nexports.parseValidatorKey = parseValidatorKey;\nfunction parseValidatorKeys(text) {\n    let buffers = parse(text, validatorKeys_1.VALIDATOR_SECRETKEY_LENGTH);\n    return buffers.map(buffer => new validatorKeys_1.ValidatorSecretKey(buffer));\n}\nexports.parseValidatorKeys = parseValidatorKeys;\nfunction parse(text, expectedLength) {\n    // Split by newlines, trim whitespace, then discard remaining empty lines.\n    let lines = text.split(/\\r?\\n/).map(line => line.trim()).filter(line => line.length > 0);\n    let buffers = [];\n    let linesAccumulator = [];\n    for (const line of lines) {\n        if (line.startsWith(\"-----BEGIN\")) {\n            linesAccumulator = [];\n        }\n        else if (line.startsWith(\"-----END\")) {\n            let asBase64 = linesAccumulator.join(\"\");\n            let asHex = Buffer.from(asBase64, \"base64\").toString();\n            let asBytes = Buffer.from(asHex, \"hex\");\n            if (asBytes.length != expectedLength) {\n                throw new errors_1.ErrBadPEM(`incorrect key length: expected ${expectedLength}, found ${asBytes.length}`);\n            }\n            buffers.push(asBytes);\n            linesAccumulator = [];\n        }\n        else {\n            linesAccumulator.push(line);\n        }\n    }\n    if (linesAccumulator.length != 0) {\n        throw new errors_1.ErrBadPEM(\"incorrect file structure\");\n    }\n    return buffers;\n}\nexports.parse = parse;\n//# sourceMappingURL=pem.js.map"]},"metadata":{},"sourceType":"script"}