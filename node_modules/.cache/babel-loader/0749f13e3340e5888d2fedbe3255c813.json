{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Code = void 0;\n/**\n * Bytecode of a Smart Contract, as an abstraction.\n */\nvar Code = /*#__PURE__*/function () {\n  function Code(hex) {\n    _classCallCheck(this, Code);\n    this.hex = hex;\n  }\n  /**\n   * Creates a Code object from a buffer (sequence of bytes).\n   */\n  _createClass(Code, [{\n    key: \"toString\",\n    value:\n    /**\n     * Returns the bytecode as a hex-encoded string.\n     */\n    function toString() {\n      return this.hex;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return Buffer.from(this.hex, \"hex\");\n    }\n  }], [{\n    key: \"fromBuffer\",\n    value: function fromBuffer(code) {\n      return new Code(code.toString(\"hex\"));\n    }\n  }]);\n  return Code;\n}();\nexports.Code = Code;","map":{"version":3,"sources":["../../src/smartcontracts/code.ts"],"names":[],"mappings":";;;;;;;;AAAA;;AAEG;AAFH,IAGa,IAAI;EAGb,SAAA,KAAoB,GAAW,EAAA;IAAA,eAAA,OAAA,IAAA;IAC3B,IAAI,CAAC,GAAG,GAAG,GAAG;EAClB;EAEA;;AAEG;EAFH,YAAA,CAAA,IAAA;IAAA,GAAA;IAAA,KAAA;IAOA;;AAEG;IACH,SAAA,SAAA,EAAQ;MACJ,OAAO,IAAI,CAAC,GAAG;IACnB;EAAC;IAAA,GAAA;IAAA,KAAA,EAED,SAAA,QAAA,EAAO;MACH,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC;IACvC;EAAC;IAAA,GAAA;IAAA,KAAA,EAbD,SAAA,WAAkB,IAAY,EAAA;MAC1B,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IACzC;EAAC;EAAA,OAAA,IAAA;AAAA;AAZL,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Code = void 0;\n/**\n * Bytecode of a Smart Contract, as an abstraction.\n */\nclass Code {\n    constructor(hex) {\n        this.hex = hex;\n    }\n    /**\n     * Creates a Code object from a buffer (sequence of bytes).\n     */\n    static fromBuffer(code) {\n        return new Code(code.toString(\"hex\"));\n    }\n    /**\n     * Returns the bytecode as a hex-encoded string.\n     */\n    toString() {\n        return this.hex;\n    }\n    valueOf() {\n        return Buffer.from(this.hex, \"hex\");\n    }\n}\nexports.Code = Code;\n//# sourceMappingURL=code.js.map"]},"metadata":{},"sourceType":"script"}