{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/neville/Documents/Github/elrond-delegation/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar createHash = require(\"create-hash\");\nvar pbkdf2_1 = require(\"pbkdf2\");\nvar randomBytes = require(\"randombytes\");\nvar _wordlists_1 = require(\"./_wordlists\");\nvar DEFAULT_WORDLIST = _wordlists_1._default;\nvar INVALID_MNEMONIC = 'Invalid mnemonic';\nvar INVALID_ENTROPY = 'Invalid entropy';\nvar INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nvar WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' + 'Please explicitly pass a 2048 word array explicitly.';\nfunction lpad(str, padString, length) {\n  while (str.length < length) str = padString + str;\n  return str;\n}\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n  return bytes.map(function (x) {\n    return lpad(x.toString(2), '0', 8);\n  }).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n  var ENT = entropyBuffer.length * 8;\n  var CS = ENT / 32;\n  var hash = createHash('sha256').update(entropyBuffer).digest();\n  return bytesToBinary(_toConsumableArray(hash)).slice(0, CS);\n}\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n  var mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n  var saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n  return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n  return new Promise(function (resolve, reject) {\n    try {\n      var mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n      var saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n      pbkdf2_1.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', function (err, data) {\n        if (err) return reject(err);else return resolve(data);\n      });\n    } catch (error) {\n      return reject(error);\n    }\n  });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST;\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  }\n  var words = (mnemonic || '').normalize('NFKD').split(' ');\n  if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC);\n  // convert word indices to 11 bit binary strings\n  var bits = words.map(function (word) {\n    var index = wordlist.indexOf(word);\n    if (index === -1) throw new Error(INVALID_MNEMONIC);\n    return lpad(index.toString(2), '0', 11);\n  }).join('');\n  // split the binary string into ENT/CS\n  var dividerIndex = Math.floor(bits.length / 33) * 32;\n  var entropyBits = bits.slice(0, dividerIndex);\n  var checksumBits = bits.slice(dividerIndex);\n  // calculate the checksum and compare\n  var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n  if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY);\n  if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY);\n  if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY);\n  var entropy = Buffer.from(entropyBytes);\n  var newChecksum = deriveChecksumBits(entropy);\n  if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM);\n  return entropy.toString('hex');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) entropy = Buffer.from(entropy, 'hex');\n  wordlist = wordlist || DEFAULT_WORDLIST;\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  }\n  // 128 <= ENT <= 256\n  if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY);\n  if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY);\n  if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY);\n  var entropyBits = bytesToBinary(_toConsumableArray(entropy));\n  var checksumBits = deriveChecksumBits(entropy);\n  var bits = entropyBits + checksumBits;\n  var chunks = bits.match(/(.{1,11})/g);\n  var words = chunks.map(function (binary) {\n    var index = binaryToByte(binary);\n    return wordlist[index];\n  });\n  return wordlist[0] === \"\\u3042\\u3044\\u3053\\u304F\\u3057\\u3093\" // Japanese wordlist\n  ? words.join(\"\\u3000\") : words.join(' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n  strength = strength || 128;\n  if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY);\n  rng = rng || randomBytes;\n  return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\nexports.validateMnemonic = validateMnemonic;\nfunction setDefaultWordlist(language) {\n  var result = _wordlists_1.wordlists[language];\n  if (result) DEFAULT_WORDLIST = result;else throw new Error('Could not find wordlist for language \"' + language + '\"');\n}\nexports.setDefaultWordlist = setDefaultWordlist;\nfunction getDefaultWordlist() {\n  if (!DEFAULT_WORDLIST) throw new Error('No Default Wordlist set');\n  return Object.keys(_wordlists_1.wordlists).filter(function (lang) {\n    if (lang === 'JA' || lang === 'EN') return false;\n    return _wordlists_1.wordlists[lang].every(function (word, index) {\n      return word === DEFAULT_WORDLIST[index];\n    });\n  })[0];\n}\nexports.getDefaultWordlist = getDefaultWordlist;\nvar _wordlists_2 = require(\"./_wordlists\");\nexports.wordlists = _wordlists_2.wordlists;","map":{"version":3,"names":["_toConsumableArray","require","default","Object","defineProperty","exports","value","createHash","pbkdf2_1","randomBytes","_wordlists_1","DEFAULT_WORDLIST","_default","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","WORDLIST_REQUIRED","lpad","str","padString","length","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","join","deriveChecksumBits","entropyBuffer","ENT","CS","hash","update","digest","slice","salt","password","mnemonicToSeedSync","mnemonic","mnemonicBuffer","Buffer","from","normalize","saltBuffer","pbkdf2Sync","mnemonicToSeed","Promise","resolve","reject","pbkdf2","err","data","error","mnemonicToEntropy","wordlist","Error","words","split","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","entropy","newChecksum","entropyToMnemonic","isBuffer","TypeError","chunks","binary","generateMnemonic","strength","rng","validateMnemonic","e","setDefaultWordlist","language","result","wordlists","getDefaultWordlist","keys","filter","lang","every","_wordlists_2"],"sources":["/Users/neville/Documents/Github/elrond-delegation/node_modules/bip39/src/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createHash = require(\"create-hash\");\nconst pbkdf2_1 = require(\"pbkdf2\");\nconst randomBytes = require(\"randombytes\");\nconst _wordlists_1 = require(\"./_wordlists\");\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' +\n    'Please explicitly pass a 2048 word array explicitly.';\nfunction lpad(str, padString, length) {\n    while (str.length < length)\n        str = padString + str;\n    return str;\n}\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n    return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = createHash('sha256')\n        .update(entropyBuffer)\n        .digest();\n    return bytesToBinary([...hash]).slice(0, CS);\n}\nfunction salt(password) {\n    return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n    const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n    const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n    return new Promise((resolve, reject) => {\n        try {\n            const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n            const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n            pbkdf2_1.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', (err, data) => {\n                if (err)\n                    return reject(err);\n                else\n                    return resolve(data);\n            });\n        }\n        catch (error) {\n            return reject(error);\n        }\n    });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    const words = (mnemonic || '').normalize('NFKD').split(' ');\n    if (words.length % 3 !== 0)\n        throw new Error(INVALID_MNEMONIC);\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map(word => {\n        const index = wordlist.indexOf(word);\n        if (index === -1)\n            throw new Error(INVALID_MNEMONIC);\n        return lpad(index.toString(2), '0', 11);\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n    if (entropyBytes.length < 16)\n        throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length > 32)\n        throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length % 4 !== 0)\n        throw new Error(INVALID_ENTROPY);\n    const entropy = Buffer.from(entropyBytes);\n    const newChecksum = deriveChecksumBits(entropy);\n    if (newChecksum !== checksumBits)\n        throw new Error(INVALID_CHECKSUM);\n    return entropy.toString('hex');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n    if (!Buffer.isBuffer(entropy))\n        entropy = Buffer.from(entropy, 'hex');\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    // 128 <= ENT <= 256\n    if (entropy.length < 16)\n        throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length > 32)\n        throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length % 4 !== 0)\n        throw new TypeError(INVALID_ENTROPY);\n    const entropyBits = bytesToBinary([...entropy]);\n    const checksumBits = deriveChecksumBits(entropy);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = chunks.map(binary => {\n        const index = binaryToByte(binary);\n        return wordlist[index];\n    });\n    return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n        ? words.join('\\u3000')\n        : words.join(' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n    strength = strength || 128;\n    if (strength % 32 !== 0)\n        throw new TypeError(INVALID_ENTROPY);\n    rng = rng || randomBytes;\n    return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.validateMnemonic = validateMnemonic;\nfunction setDefaultWordlist(language) {\n    const result = _wordlists_1.wordlists[language];\n    if (result)\n        DEFAULT_WORDLIST = result;\n    else\n        throw new Error('Could not find wordlist for language \"' + language + '\"');\n}\nexports.setDefaultWordlist = setDefaultWordlist;\nfunction getDefaultWordlist() {\n    if (!DEFAULT_WORDLIST)\n        throw new Error('No Default Wordlist set');\n    return Object.keys(_wordlists_1.wordlists).filter(lang => {\n        if (lang === 'JA' || lang === 'EN')\n            return false;\n        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n    })[0];\n}\nexports.getDefaultWordlist = getDefaultWordlist;\nvar _wordlists_2 = require(\"./_wordlists\");\nexports.wordlists = _wordlists_2.wordlists;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}